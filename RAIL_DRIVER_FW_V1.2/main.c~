/*********************************************************************
*
* DRIVER RAIL V 1.2
*
* MAIN.C
*
*********************************************************************
* Processor: PIC18F4585
* Frequency: 32 Mhz
* Compiler: C18
*********************************************************************/
#include "main.h"
//////////////////////////////////////////////////////////////////////////////
// EEPROM READ / WRITE FUNCTION 
//////////////////////////////////////////////////////////////////////////////
/**********************************************************
	This function reads a byte at given addresse in EEPROM.
	IN:		address
	OUT:	data
	Return Value: ERROR, SUCCESS
**********************************************************/
unsigned char ReadEEPROM(unsigned int adr, unsigned char *data){

	if(adr > 0x3FF){
		return(ERROR);
	}
	else{
		EEADR = adr&0xFF;
		EEADRH = (adr>>8) & 0x3;
		EECON1bits.EEPGD = 0;	// Point to data memory
		EECON1bits.CFGS = 0;	// Access EEPROM
		EECON1bits.RD = 1;		// Read data
		*data = EEDATA;			// Load data
		return(SUCCESS);
	}
} // end of readEEPROM()

/**********************************************************
	This function verifies a byte at given addresse in EEPROM.
	IN:		addresse
	OUT:	data
	Return Value: ERROR, MATCH and DISMATCH
**********************************************************/
unsigned char VerifyEEPROM(unsigned int adr, unsigned char data){

	if(adr > 0x3FF){
		return(ERROR);
	}
	else{
		EEADR = adr&0xFF;
		EEADRH = (adr>>8) & 0x3;
		EECON1bits.EEPGD = 0;	// Point to data memory
		EECON1bits.CFGS = 0;	// Access EEPROM
		EECON1bits.RD = 1;		// Read data
		if(data == EEDATA){		// Compare data
			return(MATCH);		// Datas Matches
		}
		else{
			return(DISMATCH);	// Datas dismatches
		}
	}
} // end of readEEPROM()


/****************************************************************************
*
* Function ReadEEPROMConfig
*
****************************************************************************/
void ReadEEPROMConfig(void) {

	 unsigned char 	Value;
	 unsigned short Adr;
	 unsigned char  automationCounter;
	 unsigned char identCounter;
	 unsigned char  automationDataCounter;
	 unsigned char  checkMagicNumberCounter;
	 unsigned char  automationData[MAXTRAMESIZE];

	// Read MAGIC NUMBER
	Adr=(unsigned char)MAGICNUMBER_ADDRESS;
	for (checkMagicNumberCounter=0;checkMagicNumberCounter<MAGICNUMBERSIZE;checkMagicNumberCounter++) {
		ReadEEPROM(Adr++,&Value);
		if (Value!=checkMagicNumberCounter) {
			
			// Init EEPROM after flashing the board
			Adr=(unsigned short)MAGICNUMBER_ADDRESS;
			for (checkMagicNumberCounter=0;checkMagicNumberCounter<MAGICNUMBERSIZE;checkMagicNumberCounter++) {
				WriteEEPROM(Adr++,checkMagicNumberCounter);
			}
			// Set ANA mode
			Adr=(unsigned short)MODE_ADDRESS;
			Value=ANAValue;
			WriteEEPROM(Adr,Value);

			// No automation
			Adr=(unsigned short)LASTAUTOMATION_ADDRESS;
			Value=0;
			WriteEEPROM(Adr,Value);

			gl_mutex=1;gl_mode = ANAValue;gl_lastAutomation=0;gl_mutex=0;
			return;
		}
	}	

	// Read in EEPROM MODE 
	Adr=(unsigned short)MODE_ADDRESS;
	ReadEEPROM(Adr,&Value);
	gl_mutex=1;gl_mode=Value;gl_mutex=0;
	
	// Read in EEPROM last automation
	Adr=(unsigned short)LASTAUTOMATION_ADDRESS;
	ReadEEPROM(Adr,&Value);
	gl_lastAutomation=Value;

	// Read in EEPROM Automation
	Adr=(unsigned short)AUTOMATION_ADDRESS;
	for(automationCounter=0;automationCounter<gl_lastAutomation;automationCounter++) {
	
		for(automationDataCounter=0;automationDataCounter<gl_trameSize;automationDataCounter++) {
			ReadEEPROM(Adr++,&Value);	
			automationData[automationDataCounter]=Value;
		}
		automationDataCounter=0;
		for(identCounter=0;identCounter<MAXSIZEIDENT;identCounter++) {
			gl_automation[automationCounter].ident[identCounter]=automationData[automationDataCounter++];
		}

		gl_automation[automationCounter].automationEvent.trackEvent=automationData[automationDataCounter++];
		gl_automation[automationCounter].automationEvent.eventBoardTrackNumber=automationData[automationDataCounter++];
		gl_automation[automationCounter].automationEvent.eventTrackNumber=automationData[automationDataCounter++];
		gl_automation[automationCounter].automationEvent.eventVehicleStatus=automationData[automationDataCounter++];

		gl_automation[automationCounter].automationEvent.GPIOEvent=automationData[automationDataCounter++];
		gl_automation[automationCounter].automationEvent.eventBoardGPIONumber=automationData[automationDataCounter++];
		gl_automation[automationCounter].automationEvent.eventGPIONumber=automationData[automationDataCounter++];
		gl_automation[automationCounter].automationEvent.eventGPIOLevel=automationData[automationDataCounter++];

		gl_automation[automationCounter].automationCommand.setGPIO = automationData[automationDataCounter++];
		gl_automation[automationCounter].automationCommand.GPIONumber = automationData[automationDataCounter++];
		gl_automation[automationCounter].automationCommand.GPIOLevel = automationData[automationDataCounter++];

		gl_automation[automationCounter].automationCommand.setLpo = automationData[automationDataCounter++];
		gl_automation[automationCounter].automationCommand.lpoNumber = automationData[automationDataCounter++];
		gl_automation[automationCounter].automationCommand.lpoLevel = automationData[automationDataCounter++];

		gl_automation[automationCounter].automationCommand.setTrack = automationData[automationDataCounter++];
		gl_automation[automationCounter].automationCommand.trackNumber = automationData[automationDataCounter++];
		gl_automation[automationCounter].automationCommand.trackSpeed = automationData[automationDataCounter++];
		gl_automation[automationCounter].automationCommand.trackDir = automationData[automationDataCounter++];

		gl_automation[automationCounter].automationCommand.setDcc =automationData[automationDataCounter++];
		gl_automation[automationCounter].automationCommand.dccAddress = automationData[automationDataCounter++];
		gl_automation[automationCounter].automationCommand.dccCommand = automationData[automationDataCounter++];

		gl_automation[automationCounter].automationCommand.getGPIOStatus = automationData[automationDataCounter++];
		gl_automation[automationCounter].automationCommand.getLpoStatus = automationData[automationDataCounter++];
		gl_automation[automationCounter].automationCommand.getTrackStatus = automationData[automationDataCounter++];
		gl_automation[automationCounter].automationCommand.getBoardStatus = automationData[automationDataCounter++];
		gl_automation[automationCounter].automationCommand.getAutomationList = automationData[automationDataCounter++];
	}
}

/**********************************************************
	This function informs on if write to EEPROM is completed.
	IN:		None
	OUT:	None
	Return Value: IN_PROGRESS, SUCCESS
**********************************************************/
unsigned char WriteCompletedEEPROM(void) {

	if(PIR2bits.EEIF){
		PIR2bits.EEIF=0;		// Clear write complete flag
		EECON1bits.WREN = 0;	// Disable write
		return(SUCCESS);		// Write to EEPROM completed
	}
	else {
		return(ERROR);			// Write to EEPROM not completed
	}
}

/**********************************************************
	This function informs on if it is possible to write in EEPROM.
	IN:		None
	OUT:	None
	Return Value: ERROR, SUCCESS
**********************************************************/
unsigned char WriteRdyEEPROM(void){

	if(!EECON1bits.WR) {
		return(SUCCESS);	// New Write Enabled
	}
	else {
		return(ERROR);		// new Write Disabled
	}
}

/**********************************************************
	This function writes a byte at given addresse in EEPROM.
	IN:		addresse, data
	Return Value: ERROR, SUCCESS
**********************************************************/
unsigned char WriteEEPROM(unsigned short adr, unsigned char data){
	if(adr > 0x3FF){
		return(ERROR);
	}
	else{

		// Wait eeprom ready to be written
		while (WriteRdyEEPROM()==(unsigned char) ERROR);

		EEADR = adr&0xFF;			// Address of the data in EEPROM
		EEADRH = (adr>>8) & 0x3;	// Address of the data in EEPROM
		EEDATA = data;				// Data to write in EEPROM
		EECON1bits.EEPGD = 0;		// Point to data memory
		EECON1bits.CFGS = 0;		// Access EEPROM
		EECON1bits.WREN = 1;		// Enable write
		INTCONbits.GIE	= 0;		// Disable Interrupt
		EECON2 = 0x55;
		EECON2 = 0x0AA;
		EECON1bits.WR = 1;			// Begin write

		// Wait data written
		while (WriteCompletedEEPROM()==(unsigned char) IN_PROGRESS);
		while (WriteRdyEEPROM()==(unsigned char) ERROR);

		INTCONbits.GIE		= 1;	// Enable Interrupt
	
		return(SUCCESS);
	}
} // end of WriteEEPROM()

//////////////////////////////////////////////////////////////////////////////
// PARSER AND REQUEST MANAGEMENT
//////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// isAdigit
/////////////////////////////////////////////////////////////////////////////
unsigned char isAdigit(unsigned char car) {
	if (car >='0' && car <= '9') return TRUE;
	else return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// isAhexaDigit
/////////////////////////////////////////////////////////////////////////////
unsigned char isAhexaDigit(unsigned char car) {
	if ((car >='a' && car <= 'f')  || (car >='A' && car <= 'F')) return TRUE;
	else return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// toUpperCase
/////////////////////////////////////////////////////////////////////////////
unsigned char toUpperCase(unsigned char car) {

    unsigned char returnValue;

	if (car >='a' && car <= 'z') returnValue=car - 0x20;
	else returnValue=car;

	return(returnValue);
}
/////////////////////////////////////////////////////////////////////////////
// strtol_with_atoi for positive number
/////////////////////////////////////////////////////////////////////////////
unsigned short strtol_with_atoi(const char* nptr, short base) {

	unsigned short result=0;
	unsigned char getData=FALSE;

    // TRACE
    // if (gl_inputCounter==0) printf("\n\rLine %d strtol_with_atoi(%s, ,%d)",__LINE__,nptr,base);

	// Check sign
	if (*nptr == '-') {
		errno = ERANGE;

   		 // TRACE
   		 // if (gl_inputCounter==0) printf("\n\rLine %d strtol_with_atoi(%s, ,%d) return with ERANGE",__LINE__,nptr,base);
		return result;
	}
	else if (*nptr == '+') {
		nptr++;
	}

	// Check base 0x for hexadécimal, 0 for octal
	if (base == 0) {
		if (*nptr == '0') {
			nptr++;
			getData=TRUE;
			if (*nptr == 'x' || *nptr == 'X') {
				nptr++;
				base = 16;
				getData=FALSE;
			}
		}
		else {
			base = 10;
		}
	}

	// atoi()
	result = 0;
	while (*nptr != '\0') {
		int digit;
		if (isAdigit(*nptr)) {
			digit = *nptr - '0';
			getData=TRUE;
		}
		else if (base == 16 && isAhexaDigit(*nptr)) {
			digit = toUpperCase(*nptr) - 'A' + 10;
			getData=TRUE;
			//TRACE
			// if (gl_inputCounter==0) printf("\n\rdigit = %d",digit);
		}
		else {
			// end converstion
			// TRACE
   		    // if (gl_inputCounter==0) printf("\n\rLine %d End conversion on [%c]",__LINE__,*nptr);
			break;
		}

		// Check value for base
		if (digit >= base) {
			// Fin de la conversion
			errno = ERANGE;
   		
		    // TRACE
   		    // if (gl_inputCounter==0) printf("\n\rLine %d strtol_with_atoi(%s, ,%d) ERANGE digit = %d toUpperCase(*nptr) = %c",__LINE__,nptr,base,digit,toUpperCase(*nptr));
			return result;
		}

		result = result * base + digit;
		nptr++;
	}

	// TRACE
    // if (gl_inputCounter==0) printf("\n\rLine %d strtol_with_atoi(%s, ,%d) return %d",__LINE__,nptr,base,result);
	if (getData==FALSE) errno = EINVAL;
	return result;
}

/////////////////////////////////////////////////////////////////////////////
// traceValue 
/////////////////////////////////////////////////////////////////////////////
unsigned char *traceValue(unsigned char data) {

	static unsigned char token[MAXSIZETOKEN];

	switch (data) {
		case  PROGValue:sprintf(token,PROG); break; 
		case  COMValue:sprintf(token,COM); break;
		case  DCCValue:sprintf(token,DCC); break;
		case  STOPValue:sprintf(token,STOP); break;
		case  RUNALLValue:sprintf(token,RUNALL); break;
		case  ANAValue:sprintf(token,ANA); break;
		case  LPOValue:sprintf(token,LPO); break;
		case  GPIOValue:sprintf(token,GPIO); break;
		case  TRACKValue:sprintf(token,TRACK); break;
		case  VALValue:sprintf(token,VAL); break;
		case  INValue:sprintf(token,IN); break;
		case  ACTValue:sprintf(token,ACT); break;
		case  STAValue:sprintf(token,STA); break;
		case  OUTValue:sprintf(token,OUT); break;
		case  ONTRACKValue:sprintf(token,ONTRACK); break;
		case  OFFTRACKValue:sprintf(token,OFFTRACK); break;
		case  DELValue:sprintf(token,DEL); break;
		case  DIRValue:sprintf(token,DIR); break;
		case  FORWValue:sprintf(token,FORW); break;
		case  BACKValue:sprintf(token,BACK); break;
		case  GSTATValue:sprintf(token,GSTAT); break;
		case  TSTATValue:sprintf(token,TSTAT); break;
		case  BSTATValue:sprintf(token,BSTAT); break;
		case  AUTLISTValue:sprintf(token,AUTLIST); break;
		case  AUTValue:sprintf(token,AUT); break;
		case  BOARDValue:sprintf(token,BOARD); break;
		case  ERRValue:sprintf(token,ERR); break;
		case  AUTFULLValue:sprintf(token,AUTFULL); break;
		case  NOAUTValue:sprintf(token,NOAUT); break;
		case  TIMEOUTValue:sprintf(token,TIMEOUT); break;
		case  NODCCValue:sprintf(token,NODCC); break;
		case  NOANAValue:sprintf(token,NOANA); break;
		case  GPIOINValue:sprintf(token,GPIOIN); break;
		case  RUNValue:sprintf(token,RUN); break;
		case  RESETValue:sprintf(token,RESET); break;
		default:sprintf(token,"UNDEFINED");
	}
	return(token);
}
/////////////////////////////////////////////////////////////////////////////
// traceError 
/////////////////////////////////////////////////////////////////////////////
void traceError() {

	if (gl_inputCounter!=0) return;

	switch (gl_parserErrorCode) {	
		case UNKNOWN_TOKEN				:		printf("\n\rUnknown token");break;
		case NUMBER_MISSING				:		printf("\n\rNumber missing");break;
		case INCOMPLETE_REQUEST			:		printf("\n\rIncomplete request");break;
		case BAD_NUMBER					:		printf("\n\rBad number");break;
		case MODE_MISSING				:		printf("\n\rMode is missing");break;
		case BAD_GPIO_NUMBER			:		printf("\n\rBad GPIO number");break;
		case BAD_LPO_NUMBER				:		printf("\n\rBad LPO number");break;
		case BAD_GPIO_DIR				:		printf("\n\rBad GPIO direction");break;
		case CANT_SET_GPIO_IN_INPUT_MODE:		printf("\n\rCan't set GPIO, need to be set as output");break;
		case BAD_GPIO_LEVEL				:		printf("\n\rBad GPIO level");break;
		case BAD_LPO_LEVEL				:		printf("\n\rBad Low Power Output level");break;
		case BAD_TRACK_SPEED			:		printf("\n\rBad track speed");break;
		case BAD_TRACK_DIR				:		printf("\n\rBad track direction");break;
		case BAD_TRACK_NUMBER			:		printf("\n\rBad track number");break;
		case BAD_MODE					:		printf("\n\rBad mode");break;
		case WRONG_BOARD_NUMBER			:		printf("\n\rWrong board number");break;
		case AUTOMATIONSIZELIMIT		:		printf("\n\rNo more automation available");break;
		default : printf("\n\rUnknown Error...");
	}
}

/////////////////////////////////////////////////////////////////////////////
// getToken 
// return value TRUE if parsing correct, otherwise FALSE 
/////////////////////////////////////////////////////////////////////////////
unsigned char getToken(unsigned char* inputString, unsigned char* inputToken, unsigned char* stringPointer) {

	 unsigned char carCounter = 0;
	 unsigned char tokenCarPointer = 0;
	 unsigned char testToken[MAXSIZETOKEN];

    // TRACE
    // if (gl_inputCounter==0) printf("\n\rLine %d getToken(%s,%s,%d)",__LINE__,inputString,inputToken,*stringPointer);

	for (carCounter=0; carCounter < strlen(inputString); carCounter++) {
		if (inputString[carCounter]==' ') {
			(*stringPointer)++;
			continue; // remove space
		}
		testToken[tokenCarPointer++] = inputString[carCounter];

		(*stringPointer)++;
		if (!strncmp(testToken, inputToken, strlen(inputToken))) {

			// TRACE
        	// if (gl_inputCounter==0) printf("\n\rLine %d getToken(%s,%s,%d) return TRUE",__LINE__,inputString,inputToken,*stringPointer);
			return(TRUE);
		}

		// Error
		if (tokenCarPointer == ((strlen(inputToken)<MAXSIZETOKEN-1) ? strlen(inputToken):MAXSIZETOKEN - 1)) {
			gl_parserErrorCode = UNKNOWN_TOKEN;

			// TRACE
        	// if (gl_inputCounter==0) printf("\n\rLine %d getToken(%s,%s,%d) return FALSE",__LINE__,inputString,inputToken,*stringPointer);
			return(FALSE);
		}
	} 
	gl_parserErrorCode = UNKNOWN_TOKEN;

	// TRACE
    // if (gl_inputCounter==0) printf("\n\rLine %d getToken(%s,%s,%d) return FALSE",__LINE__,inputString,inputToken,*stringPointer);
	return(FALSE);
}

/////////////////////////////////////////////////////////////////////////////
// getValue 
// return value TRUE if parsing correct, otherwise FALSE 
/////////////////////////////////////////////////////////////////////////////
unsigned char getValue(unsigned char* inputString, unsigned char* Value, unsigned char* stringPointer) {

	 unsigned char carCounter = 0;
	 unsigned char tokenCarPointer = 0;
	 unsigned char dataFound;
	 unsigned short number;

    // TRACE
    // if (gl_inputCounter==0) printf("\n\rLine %d getValue(%s,%d,%d)",__LINE__,inputString,*Value,*stringPointer);

	errno = 0;
	while (inputString[carCounter] == ' ' && carCounter < strlen(inputString)) {
		(*stringPointer)++;
		carCounter++;
	}

	number = strtol_with_atoi(&inputString[carCounter],0);

    // TRACE
	// if (gl_inputCounter==0) printf("\n\rLine %d strtol_with_atoi() return %d",__LINE__,*Value);

	if (errno == ERANGE || errno ==EINVAL) dataFound = FALSE;
	else dataFound = TRUE;

	if (number >255) {
		errno == ERANGE;
		gl_parserErrorCode = BAD_NUMBER;

    	// TRACE
   		//if (gl_inputCounter==0) printf("\n\rLine %d getValue(%s,%d,%d) return FALSE",__LINE__,inputString,*Value,*stringPointer);
		return(FALSE);
	}
	
	if (dataFound==TRUE) {

		while (inputString[carCounter] != ' ' && carCounter < strlen(inputString)) {
			(*stringPointer)++;
			carCounter++;
		}

		*Value=(unsigned char)number;

    	// TRACE
   		//if (gl_inputCounter==0) printf("\n\rLine %d getValue(%s,%d,%d) return TRUE",__LINE__,inputString,*Value,*stringPointer);
		return(TRUE);
	}
	else {
		gl_parserErrorCode = NUMBER_MISSING;

    	// TRACE
   		//if (gl_inputCounter==0) printf("\n\rLine %d getValue(%s,%d,%d) return FALSE",__LINE__,inputString,*Value,*stringPointer);
		return(FALSE);
	}
}

/////////////////////////////////////////////////////////////////////////////
// Parser 
// return value TRUE if parsing correct, otherwise FALSE 
// Semantic analysis on values should be done on struct inputRequest content
/////////////////////////////////////////////////////////////////////////////
unsigned char parser(unsigned char* inputString, struct inputRequest* request) {

	 unsigned char stringPointer = 0;
	 unsigned char nextStringPointer = 0;
	 unsigned char keepStringPointer;
     unsigned char token[MAXSIZETOKEN];
	 unsigned char identCounter=0;

    // TRACE
    // if (gl_inputCounter==0) printf("\n\rLine %d parser(%s,)",__LINE__,inputString);

	initRequest(request);

	// get mode PROG or COM
	keepStringPointer = stringPointer;

	//PROG
	sprintf(token,PROG);
	if (getToken(&inputString[stringPointer], token, &stringPointer)) {
		request->mode = PROGValue;

		// Get board number
		if (!getValue(&inputString[stringPointer], &request->boardNumber, &stringPointer)) return(FALSE);
		nextStringPointer = stringPointer;
	}

	//COM
	stringPointer = keepStringPointer;
	sprintf(token,COM);
	if (getToken(&inputString[stringPointer], token, &stringPointer)) {
		request->mode = COMValue;

		// Get board number
		if (!getValue(&inputString[stringPointer], &request->boardNumber, &stringPointer)) return(FALSE);
		nextStringPointer = stringPointer;
	}

	// STOP
    sprintf(token,STOP);
	stringPointer = keepStringPointer;
	if (getToken(&inputString[stringPointer], token, &stringPointer)) {
		request->globalCommand = STOPValue;
		request->boardNumber = gl_boardNumber;

		// TRACE
		// if (gl_inputCounter==0) printf("\n\rLine %d parser(%s,) return TRUE (%d,%d)",__LINE__,inputString,request->globalCommand,request->boardNumber);
		return(TRUE);
	}

	// RUNALL 
	sprintf(token, RUNALL);
	stringPointer = keepStringPointer;
	if (getToken(&inputString[stringPointer], token, &stringPointer)) {
		request->globalCommand = RUNALLValue;
		request->boardNumber = gl_boardNumber;

		// TRACE
	    // if (gl_inputCounter==0) printf("\n\rLine %d parser(%s,) return TRUE",__LINE__,inputString);
		return(TRUE);
	}

	// RUN 
	sprintf(token,RUN);
	stringPointer = keepStringPointer;
	if (getToken(&inputString[stringPointer], token, &stringPointer)) {
		request->globalCommand = RUNValue;

		// Get board number
		if (!getValue(&inputString[stringPointer], &request->boardNumber, &stringPointer)){

			// TRACE
			// if (gl_inputCounter==0) printf("\n\rLine %d parser(%s,) return FALSE",__LINE__,inputString);
			 return(FALSE);
		}

		// TRACE
	    // if (gl_inputCounter==0) printf("\n\rLine %d parser(%s,) return TRUE (%d,%d)",__LINE__,inputString,request->globalCommand,request->boardNumber);
		return(TRUE);
	}

	// RESET
	sprintf(token,RESET);
	stringPointer = keepStringPointer;
	if (getToken(&inputString[stringPointer], token, &stringPointer)) {
		request->globalCommand = RESETValue;

		// Get board number
		if (!getValue(&inputString[stringPointer], &request->boardNumber, &stringPointer)){

			// TRACE
			 // if (gl_inputCounter==0) printf("\n\rLine %d parser(%s,) return FALSE",__LINE__,inputString);
			 return(FALSE);
		}

		// TRACE
		// if (gl_inputCounter==0) printf("\n\rLine %d parser(%s,) return TRUE for board %d",__LINE__,inputString,request->boardNumber);
		return(TRUE);
	}


	stringPointer = nextStringPointer;

	// Analyse Programing request
	if (request->mode == PROGValue) {

		// get DCC or ANA or GPIO or AUT or DEL
		keepStringPointer = stringPointer;

		// DCC
		sprintf(token,DCC);
		if (getToken(&inputString[stringPointer], token, &stringPointer)) {
			request->programRequest.setBoardMode = TRUE;
			request->programRequest.boardMode = DCCValue;

			// TRACE
			// if (gl_inputCounter==0) printf("\n\rLine %d parser(%s,) return TRUE",__LINE__,inputString);
			return(TRUE);
		}
		//ANA
		sprintf(token,ANA);
		stringPointer = keepStringPointer;
		if (getToken(&inputString[stringPointer], token, &stringPointer)) {
			request->programRequest.setBoardMode = TRUE;
			request->programRequest.boardMode = ANAValue;

			// TRACE
			// if (gl_inputCounter==0) printf("\n\rLine %d parser(%s,) return TRUE",__LINE__,inputString);
			return(TRUE);
		}
		// GPIO
		sprintf(token,GPIO);
		stringPointer = keepStringPointer;
		if (getToken(&inputString[stringPointer], token, &stringPointer)) {
			request->programRequest.setGPIO = TRUE;

			// get GPIO number
			if (!getValue(&inputString[stringPointer], &request->programRequest.setGPIONumber, &stringPointer)) return(FALSE);

			// get DIR
			sprintf(token,DIR);
			if (getToken(&inputString[stringPointer], token, &stringPointer)) {

				// get IN or OUT
				keepStringPointer = stringPointer;

				// IN
				sprintf(token,IN);
				if (getToken(&inputString[stringPointer], token, &stringPointer)) {
					request->programRequest.setGPIODir = INValue;

					// TRACE
					// if (gl_inputCounter==0) printf("\n\rLine %d parser(%s,) return TRUE",__LINE__,inputString);
					return(TRUE);
				}

				// OUT
				else {
					stringPointer = keepStringPointer;
					sprintf(token,OUT);
					if (getToken(&inputString[stringPointer], token, &stringPointer)) {
						request->programRequest.setGPIODir = OUTValue;

						// TRACE
						// if (gl_inputCounter==0) printf("\n\rLine %d parser(%s,) return TRUE",__LINE__,inputString);
						return(TRUE);
					}
					else return(FALSE);
				}
			}
		}
		// AUT 
		stringPointer = keepStringPointer;
        sprintf(token,AUT);
		if (getToken(&inputString[stringPointer], token, &stringPointer)) {
			request->programRequest.setAutomation = TRUE;

			// GET AUTOMATION IDENTIFIER
			while(identCounter<MAXSIZEIDENT) {
				if (inputString[stringPointer]!=' ') {
					if(identCounter==0) {
						gl_parserErrorCode = MISSING_SPACE;
						return(FALSE);
					}
					else request->programRequest.ident[identCounter++]=inputString[stringPointer++];
				}
				else {
					if (identCounter==0) {
						identCounter++; // Get first space
						stringPointer++;
					}
					else {
						request->programRequest.ident[identCounter]='\0';
						break; // get second space
					}
				}
				if (identCounter==MAXSIZEIDENT) {
					gl_parserErrorCode = IDENTIFIER_TOO_LONG;
					return(FALSE);
				}
			}		

			//BOARD
			sprintf(token,BOARD);
			if (getToken(&inputString[stringPointer], token, &stringPointer)) {

				// get BOARD number
				int boardNumber;
				if (!getValue(&inputString[stringPointer], &boardNumber, &stringPointer)) return(FALSE);

				// get GPIO or TRACK 
				keepStringPointer = stringPointer;

				// GPIO 
				sprintf(token,GPIO);
				if (getToken(&inputString[stringPointer], token, &stringPointer)) {
					request->programRequest.GPIOEvent = TRUE;
					request->programRequest.eventBoardGPIONumber = boardNumber;

					// get GPIO number
					if (!getValue(&inputString[stringPointer], &request->programRequest.eventGPIONumber, &stringPointer)) return(FALSE);

					// VAL
					sprintf(token,VAL);
					if (!getToken(&inputString[stringPointer], token, &stringPointer)) return(FALSE);

					// get GPIO level
					if (!getValue(&inputString[stringPointer], &request->programRequest.eventGPIOLevel, &stringPointer)) return(FALSE);
				}

				// TRACK
				else {
					stringPointer = keepStringPointer;
					sprintf(token,TRACK);
					if (getToken(&inputString[stringPointer], token, &stringPointer)) {
						request->programRequest.trackEvent = TRUE;
						request->programRequest.eventBoardTrackNumber = boardNumber;

						// get TRACK number
						if (!getValue(&inputString[stringPointer], &request->programRequest.eventTrackNumber, &stringPointer)) {
					
							// TRACE
							// if (gl_inputCounter==0) printf("\n\rLine %d parser(%s,) return FALSE",__LINE__,inputString);
							return(FALSE);
						}

						// STA
						sprintf(token,STA);
						if (!getToken(&inputString[stringPointer], token, &stringPointer)) {

							// TRACE
							// if (gl_inputCounter==0) printf("\n\rLine %d parser(%s,) return FALSE",__LINE__,inputString);
							return(FALSE);
						}

						// get ONTRACK or OFFTRACK 
						keepStringPointer = stringPointer;
						sprintf(token,ONTRACK);
						if (getToken(&inputString[stringPointer], token, &stringPointer)) {
							request->programRequest.eventVehicleStatus = ONTRACKValue;
						}
						else {
							stringPointer = keepStringPointer;
							sprintf(token,OFFTRACK);
							if (getToken(&inputString[stringPointer], token, &stringPointer)) {
								request->programRequest.eventVehicleStatus = OFFTRACKValue;
							}
							else {

								// TRACE
								// if (gl_inputCounter==0) printf("\n\rLine %d parser(%s,) return FALSE",__LINE__,inputString);
								return(FALSE);
							}
						}
					}
					else {

						// TRACE
						// if (gl_inputCounter==0) printf("\n\rLine %d parser(%s,) return FALSE",__LINE__,inputString);
						return(FALSE);
					}
				}

				// ACT
				sprintf(token,ACT);
				if (!getToken(&inputString[stringPointer], token, &stringPointer)) return(FALSE);

				// get GPIO or LPO or TRACK or DCC
				keepStringPointer = stringPointer;

				// GPIO
				sprintf(token,GPIO);
				if (getToken(&inputString[stringPointer], token, &stringPointer)) {
					request->programRequest.GPIOSetting = TRUE;

					// get GPIO number
					if (!getValue(&inputString[stringPointer], &request->programRequest.actionGPIOSetNumber, &stringPointer)) {

						// TRACE
						// if (gl_inputCounter==0) printf("\n\rLine %d parser(%s,) return FALSE",__LINE__,inputString);
						return(FALSE);
					}

					// VAL
					sprintf(token,VAL);
					if (!getToken(&inputString[stringPointer], token, &stringPointer))  {

						// TRACE
						// if (gl_inputCounter==0) printf("\n\rLine %d parser(%s,) return FALSE",__LINE__,inputString);
						return(FALSE);
					}

					// get GPIO level
					if (!getValue(&inputString[stringPointer], &request->programRequest.actionGPIOSetLevel, &stringPointer))  {

						// TRACE
						// if (gl_inputCounter==0) printf("\n\rLine %d parser(%s,) return FALSE",__LINE__,inputString);
						return(FALSE);
					}

					// TRACE
					// if (gl_inputCounter==0) printf("\n\rLine %d parser(%s,) return TRUE",__LINE__,inputString);
					return(TRUE);
				}

				// LPO
				stringPointer = keepStringPointer;
				sprintf(token,LPO);
				if (getToken(&inputString[stringPointer], token, &stringPointer)) {
					request->programRequest.lpoSetting = TRUE;

					// get LPO number
					if (!getValue(&inputString[stringPointer], &request->programRequest.actionLpoSetNumber, &stringPointer)) {

						// TRACE
						// if (gl_inputCounter==0) printf("\n\rLine %d parser(%s,) return FALSE",__LINE__,inputString);
						return(FALSE);
					}

					// VAL
					sprintf(token,VAL);
					if (!getToken(&inputString[stringPointer], token, &stringPointer)) {

						// TRACE
						// if (gl_inputCounter==0) printf("\n\rLine %d parser(%s,) return FALSE",__LINE__,inputString);
						return(FALSE);
					}

					// get LPO level
					if (!getValue(&inputString[stringPointer], &request->programRequest.actionLpoSetLevel, &stringPointer)) {

						// TRACE
						// if (gl_inputCounter==0) printf("\n\rLine %d parser(%s,) return FALSE",__LINE__,inputString);
						return(FALSE);
					}

					// TRACE
					// if (gl_inputCounter==0) printf("\n\rLine %d parser(%s,) return TRUE",__LINE__,inputString);
					return(TRUE);
				}

				// TRACK
				stringPointer = keepStringPointer;
				sprintf(token,TRACK);
				if (getToken(&inputString[stringPointer], token, &stringPointer)) {
					request->programRequest.trackSetting = TRUE;

					// get TRACK number
					if (!getValue(&inputString[stringPointer], &request->programRequest.actionTrackSetNumber, &stringPointer))  {

						// TRACE
						// if (gl_inputCounter==0) printf("\n\rLine %d parser(%s,) return FALSE",__LINE__,inputString);
						return(FALSE);
					}

					// VAL
					sprintf(token,VAL);
					if (!getToken(&inputString[stringPointer], token, &stringPointer))  {

						// TRACE
						// if (gl_inputCounter==0) printf("\n\rLine %d parser(%s,) return FALSE",__LINE__,inputString);
						return(FALSE);
					}

					// get TRACK speed 
					if (!getValue(&inputString[stringPointer], &request->programRequest.actionTrackSetSpeed, &stringPointer))  {

						// TRACE
						// if (gl_inputCounter==0) printf("\n\rLine %d parser(%s,) return FALSE",__LINE__,inputString);
						return(FALSE);
					}

					// get TRACK DIR

					// DIR
					sprintf(token,DIR);
					if (!getToken(&inputString[stringPointer], token, &stringPointer))  {

						// TRACE
						// if (gl_inputCounter==0) printf("\n\rLine %d parser(%s,) return FALSE",__LINE__,inputString);
						return(FALSE);
					}

					// get FORW or BACK 
					keepStringPointer = stringPointer;
					sprintf(token,FORW);
					if (getToken(&inputString[stringPointer], token, &stringPointer)) {
						request->programRequest.actionTrackSetDir = FORWValue;
					}
					else {
						stringPointer = keepStringPointer;
						sprintf(token,BACK);
						if (getToken(&inputString[stringPointer], token, &stringPointer)) {
							request->programRequest.actionTrackSetDir = BACKValue;
						}
						else  {

						// TRACE
						// if (gl_inputCounter==0) printf("\n\rLine %d parser(%s,) return FALSE",__LINE__,inputString);
						return(FALSE);
						}
					}
					// TRACE
					// if (gl_inputCounter==0) printf("\n\rLine %d parser(%s,) return TRUE",__LINE__,inputString);
					return(TRUE);
				}

				// DCC
				stringPointer = keepStringPointer;
				sprintf(token,DCC);
				if (getToken(&inputString[stringPointer], token, &stringPointer)) {
					request->programRequest.dccSetting = TRUE;

					// Get DCC Address
					if (!getValue(&inputString[stringPointer], &request->programRequest.ActionDccAddressSetting, &stringPointer)) {

						// TRACE
						// if (gl_inputCounter==0) printf("\n\rLine %d parser(%s,) return FALSE",__LINE__,inputString);
						return(FALSE);
					}

					// get DCC Command
					if (!getValue(&inputString[stringPointer], &request->programRequest.ActionDccCommandSetting, &stringPointer)) {

						// TRACE
						// if (gl_inputCounter==0) printf("\n\rLine %d parser(%s,) return FALSE",__LINE__,inputString);
						return(FALSE);
					}

					return(TRUE);
				}

				// TRACE
				// if (gl_inputCounter==0) printf("\n\rLine %d parser(%s,) return FALSE",__LINE__,inputString);
				return(FALSE);
			}
			else {
					// TRACE
					// if (gl_inputCounter==0) printf("\n\rLine %d parser(%s,) return FALSE",__LINE__,inputString);
					return(FALSE);
				}
		}

		// DEL
		stringPointer = keepStringPointer;
		sprintf(token,DEL);
		if (getToken(&inputString[stringPointer], token, &stringPointer)) {
			request->programRequest.delAutomation = TRUE;

			// get Automation number
			if (!getValue(&inputString[stringPointer], &request->programRequest.automationNumber, &stringPointer)) {

				// TRACE
				// if (gl_inputCounter==0) printf("\n\rLine %d parser(%s,) return FALSE",__LINE__,inputString);
				return(FALSE);
			}

			// TRACE
			// if (gl_inputCounter==0) printf("\n\rLine %d parser(%s,) return TRUE",__LINE__,inputString);
			return(TRUE);
		}

	}

	// Analyse Controling request
	else if (request->mode == COMValue) {
		//Get GPIO or LPO or TRACK or DCC or STOP or RUNALL or RU

		// GPIO
		keepStringPointer = stringPointer;
		sprintf(token,GPIO);
		if (getToken(&inputString[stringPointer], token, &stringPointer)) {

			request->commandRequest.setGPIO = TRUE;

			// get GPIO number
			if (!getValue(&inputString[stringPointer], &request->commandRequest.GPIONumber, &stringPointer)) {

				// TRACE
				// if (gl_inputCounter==0) printf("\n\rLine %d parser(%s,) return FALSE",__LINE__,inputString);
				return(FALSE);
			}

			// VAL
			sprintf(token,VAL);
			if (!getToken(&inputString[stringPointer], token, &stringPointer)) {

				// TRACE
				// if (gl_inputCounter==0) printf("\n\rLine %d parser(%s,) return FALSE",__LINE__,inputString);
				return(FALSE);
			}

			// get GPIO level
			if (!getValue(&inputString[stringPointer], &request->commandRequest.GPIOLevel, &stringPointer)) {

				// TRACE
				// if (gl_inputCounter==0) printf("\n\rLine %d parser(%s,) return FALSE",__LINE__,inputString);
				return(FALSE);
			}

			// TRACE
			// if (gl_inputCounter==0) printf("\n\rLine %d parser(%s,) return TRUE",__LINE__,inputString);
			return(TRUE);
		}

		// LPO 
		stringPointer = keepStringPointer;
		sprintf(token,LPO);
		if (getToken(&inputString[stringPointer], token, &stringPointer)) {

			request->commandRequest.setLpo = TRUE;

			// get GPIO number
			if (!getValue(&inputString[stringPointer], &request->commandRequest.lpoNumber, &stringPointer)) {

				// TRACE
				// if (gl_inputCounter==0) printf("\n\rLine %d parser(%s,) return FALSE",__LINE__,inputString);
				return(FALSE);
			}

			// VAL
			sprintf(token,VAL);
			if (!getToken(&inputString[stringPointer], token, &stringPointer)) {

				// TRACE
				// if (gl_inputCounter==0) printf("\n\rLine %d parser(%s,) return FALSE",__LINE__,inputString);
				return(FALSE);
			}

			// get GPIO level
			if (!getValue(&inputString[stringPointer], &request->commandRequest.lpoLevel, &stringPointer)) {

				// TRACE
				// if (gl_inputCounter==0) printf("\n\rLine %d parser(%s,) return FALSE",__LINE__,inputString);
				return(FALSE);
			}

			// TRACE
			// if (gl_inputCounter==0) printf("\n\rLine %d parser(%s,) return TRUE",__LINE__,inputString);
			return(TRUE);
		}

		// TRACK
		stringPointer = keepStringPointer;
		sprintf(token,TRACK);
		if (getToken(&inputString[stringPointer], token, &stringPointer)) {

			request->commandRequest.setTrack = TRUE;

			// get TRACK number
			if (!getValue(&inputString[stringPointer], &request->commandRequest.trackNumber, &stringPointer)) {

				// TRACE
				// if (gl_inputCounter==0) printf("\n\rLine %d parser(%s,) return FALSE",__LINE__,inputString);
				return(FALSE);
			}

			// VAL
			sprintf(token,VAL);
			if (!getToken(&inputString[stringPointer], token, &stringPointer)) {

				// TRACE
				// if (gl_inputCounter==0) printf("\n\rLine %d parser(%s,) return FALSE",__LINE__,inputString);
				return(FALSE);
			}

			// get TRACK speed 
			if (!getValue(&inputString[stringPointer], &request->commandRequest.trackSpeed, &stringPointer)) {

				// TRACE
				// if (gl_inputCounter==0) printf("\n\rLine %d parser(%s,) return FALSE",__LINE__,inputString);
				return(FALSE);
			}

			// get TRACK DIR

			// DIR
			sprintf(token,DIR);
			if (!getToken(&inputString[stringPointer], token, &stringPointer)) {

				// TRACE
				// if (gl_inputCounter==0) printf("\n\rLine %d parser(%s,) return FALSE",__LINE__,inputString);
				return(FALSE);
			}

			// get FORW or BACK 
			keepStringPointer = stringPointer;
			sprintf(token,FORW);
			if (getToken(&inputString[stringPointer], token, &stringPointer)) {
				request->commandRequest.trackDir = FORWValue;
			}
			else {
				stringPointer = keepStringPointer;
				sprintf(token,BACK);
				if (getToken(&inputString[stringPointer], token, &stringPointer)) {
					request->commandRequest.trackDir = BACKValue;
				}
				else {

					// TRACE
					// if (gl_inputCounter==0) printf("\n\rLine %d parser(%s,) return FALSE",__LINE__,inputString);
					return(FALSE);
				}
			}

			// TRACE
			// if (gl_inputCounter==0) printf("\n\rLine %d parser(%s,) return TRUE",__LINE__,inputString);
			return(TRUE);
		}

		// DCC
		stringPointer = keepStringPointer;
		sprintf(token,DCC);
		if (getToken(&inputString[stringPointer], token, &stringPointer)) {
			request->commandRequest.setDcc = TRUE;

			// Get DCC Address
			if (!getValue(&inputString[stringPointer], &request->commandRequest.dccAddress, &stringPointer))  {

				// TRACE
				// if (gl_inputCounter==0) printf("\n\rLine %d parser(%s,) return FALSE",__LINE__,inputString);
				return(FALSE);
			}

			// get DCC Command
			if (!getValue(&inputString[stringPointer], &request->commandRequest.dccCommand, &stringPointer))  {

				// TRACE
				// if (gl_inputCounter==0) printf("\n\rLine %d parser(%s,) return FALSE",__LINE__,inputString);
				return(FALSE);
			}
			// TRACE
			// if (gl_inputCounter==0) printf("\n\rLine %d parser(%s,) return TRUE",__LINE__,inputString);
			return(TRUE);
		}

		// GSTAT
		stringPointer = keepStringPointer;
		sprintf(token,GSTAT);
		if (getToken(&inputString[stringPointer], token, &stringPointer)) {
			request->commandRequest.getGPIOStatus = TRUE;

			// TRACE
			// if (gl_inputCounter==0) printf("\n\rLine %d parser(%s,) return TRUE",__LINE__,inputString);
			return(TRUE);
		}
		// LSTAT
		stringPointer = keepStringPointer;
		sprintf(token,LSTAT);
		if (getToken(&inputString[stringPointer], token, &stringPointer)) {
			request->commandRequest.getLpoStatus = TRUE;

			// TRACE
			// if (gl_inputCounter==0) printf("\n\rLine %d parser(%s,) return TRUE",__LINE__,inputString);
			return(TRUE);
		}
		// TSTAT
		stringPointer = keepStringPointer;
		sprintf(token,TSTAT);
		if (getToken(&inputString[stringPointer], token, &stringPointer)) {
			request->commandRequest.getTrackStatus = TRUE;

			// TRACE
			// if (gl_inputCounter==0) printf("\n\rLine %d parser(%s,) return TRUE",__LINE__,inputString);
			return(TRUE);
		}
		// BSTAT
		stringPointer = keepStringPointer;
		sprintf(token,BSTAT);
		if (getToken(&inputString[stringPointer], token, &stringPointer)) {
			request->commandRequest.getBoardStatus = TRUE;

			// TRACE
			// if (gl_inputCounter==0) printf("\n\rLine %d parser(%s,) return TRUE",__LINE__,inputString);
			return(TRUE);
		}
		// AUTLIST
		stringPointer = keepStringPointer;
		sprintf(token,AUTLIST);
		if (getToken(&inputString[stringPointer], token, &stringPointer)) {
			request->commandRequest.getAutomationList = TRUE;

			// TRACE
			// if (gl_inputCounter==0) printf("\n\rLine %d parser(%s,) return TRUE",__LINE__,inputString);
			return(TRUE);
		}
	}
	// TRACE
	// if (gl_inputCounter==0) printf("\n\rLine %d parser(%s,) return FALSE",__LINE__,inputString);
	return(FALSE);
}


/////////////////////////////////////////////////////////////////////////////
// setRequest 
/////////////////////////////////////////////////////////////////////////////
void setRequest(struct inputRequest* request, unsigned char* data,unsigned char init) {

    unsigned char dataCounter=0;
	unsigned char identCounter;

	// set request
	request->mode = init==TRUE ? 0 : data[dataCounter] ; dataCounter++;
	request->boardNumber = init==TRUE ? 0 : data[dataCounter] ; dataCounter++;
	request->globalCommand = init==TRUE ? 0 : data[dataCounter] ; dataCounter++;

	request->commandRequest.setGPIO = init==TRUE ? 0 : data[dataCounter] ; dataCounter++;
	request->commandRequest.GPIONumber = init==TRUE ? 0 : data[dataCounter] ; dataCounter++;
	request->commandRequest.GPIOLevel = init == TRUE ? 0 : data[dataCounter] ; dataCounter++;

	request->commandRequest.setLpo = init == TRUE ? 0 : data[dataCounter] ; dataCounter++;
	request->commandRequest.lpoNumber = init == TRUE ? 0 : data[dataCounter] ; dataCounter++;
	request->commandRequest.lpoLevel = init == TRUE ? 0 : data[dataCounter] ; dataCounter++;

	request->commandRequest.setTrack = init == TRUE ? 0 : data[dataCounter] ; dataCounter++;
	request->commandRequest.trackNumber = init == TRUE ? 0 : data[dataCounter] ; dataCounter++;
	request->commandRequest.trackSpeed = init == TRUE ? 0 : data[dataCounter] ; dataCounter++;
	request->commandRequest.trackDir = init == TRUE ? 0 : data[dataCounter] ; dataCounter++;

	request->commandRequest.setDcc = init == TRUE ? 0 : data[dataCounter] ; dataCounter++;
	request->commandRequest.dccAddress = init == TRUE ? 0 : data[dataCounter] ; dataCounter++;
	request->commandRequest.dccCommand = init == TRUE ? 0 : data[dataCounter] ; dataCounter++;

	request->commandRequest.getGPIOStatus = init == TRUE ? 0 : data[dataCounter] ; dataCounter++;
	request->commandRequest.getLpoStatus = init == TRUE ? 0 : data[dataCounter] ; dataCounter++;
	request->commandRequest.getTrackStatus = init == TRUE ? 0 : data[dataCounter] ; dataCounter++;
	request->commandRequest.getBoardStatus = init == TRUE ? 0 : data[dataCounter] ; dataCounter++;
	request->commandRequest.getAutomationList = init == TRUE ? 0 : data[dataCounter] ; dataCounter++;

	request->programRequest.setBoardMode = init == TRUE ? 0 : data[dataCounter] ; dataCounter++;
	request->programRequest.boardMode = init == TRUE ? 0 : data[dataCounter] ; dataCounter++;

	request->programRequest.setGPIO = init == TRUE ? 0 : data[dataCounter] ; dataCounter++;
	request->programRequest.setGPIONumber = init == TRUE ? 0 : data[dataCounter] ; dataCounter++;
	request->programRequest.setGPIODir = init == TRUE ? 0 : data[dataCounter] ; dataCounter++;

	request->programRequest.setAutomation = init == TRUE ? 0 : data[dataCounter] ; dataCounter++;

	for (identCounter=0;identCounter<MAXSIZEIDENT;identCounter++) {
		request->programRequest.ident[identCounter] = init == TRUE ? 0 : data[dataCounter] ; dataCounter++;
	}

	request->programRequest.GPIOEvent = init == TRUE ? 0 : data[dataCounter] ; dataCounter++;
	request->programRequest.eventBoardGPIONumber = init == TRUE ? 0 : data[dataCounter] ; dataCounter++;
	request->programRequest.eventGPIONumber = init == TRUE ? 0 : data[dataCounter] ; dataCounter++;
	request->programRequest.eventGPIOLevel = init == TRUE ? 0 : data[dataCounter] ; dataCounter++;

	request->programRequest.trackEvent = init == TRUE ? 0 : data[dataCounter] ; dataCounter++;
	request->programRequest.eventBoardTrackNumber = init == TRUE ? 0 : data[dataCounter] ; dataCounter++;
	request->programRequest.eventTrackNumber = init == TRUE ? 0 : data[dataCounter] ; dataCounter++;
	request->programRequest.eventVehicleStatus = init == TRUE ? 0 : data[dataCounter] ; dataCounter++;

	request->programRequest.GPIOSetting = init == TRUE ? 0 : data[dataCounter] ; dataCounter++;
	request->programRequest.actionGPIOSetNumber = init == TRUE ? 0 : data[dataCounter] ; dataCounter++;
	request->programRequest.actionGPIOSetLevel = init == TRUE ? 0 : data[dataCounter] ; dataCounter++;

	request->programRequest.lpoSetting = init == TRUE ? 0 : data[dataCounter] ; dataCounter++;
	request->programRequest.actionLpoSetNumber=  init == TRUE ? 0 : data[dataCounter] ; dataCounter++;
	request->programRequest.actionLpoSetLevel = init == TRUE ? 0 : data[dataCounter] ; dataCounter++;

	request->programRequest.trackSetting = init == TRUE ? 0 : data[dataCounter] ; dataCounter++;
	request->programRequest.actionTrackSetNumber = init == TRUE ? 0 : data[dataCounter] ; dataCounter++;
	request->programRequest.actionTrackSetSpeed = init == TRUE ? 0 : data[dataCounter] ; dataCounter++;
	request->programRequest.actionTrackSetDir = init == TRUE ? 0 : data[dataCounter] ; dataCounter++;

	request->programRequest.dccSetting = init == TRUE ? 0 : data[dataCounter] ; dataCounter++;
	request->programRequest.ActionDccAddressSetting = init == TRUE ? 0 : data[dataCounter] ; dataCounter++;
	request->programRequest.ActionDccCommandSetting = init == TRUE ? 0 : data[dataCounter] ; dataCounter++;

	request->programRequest.delAutomation = init == TRUE ? 0 : data[dataCounter] ; dataCounter++;
	request->programRequest.automationNumber = init == TRUE ? 0 : data[dataCounter] ; dataCounter++;

	request->eventRequest.trackEvent = init == TRUE ? 0 : data[dataCounter] ; dataCounter++;
	request->eventRequest.eventBoardTrackNumber = init == TRUE ? 0 : data[dataCounter] ; dataCounter++;
	request->eventRequest.eventTrackNumber = init == TRUE ? 0 : data[dataCounter] ; dataCounter++;
	request->eventRequest.eventVehicleStatus = init == TRUE ? 0 : data[dataCounter] ; dataCounter++;

	request->eventRequest.GPIOEvent = init == TRUE ? 0 : data[dataCounter] ; dataCounter++;
	request->eventRequest.eventBoardGPIONumber = init == TRUE ? 0 : data[dataCounter] ; dataCounter++;
	request->eventRequest.eventGPIONumber = init == TRUE ? 0 : data[dataCounter] ; dataCounter++;
	request->eventRequest.eventGPIOLevel = init == TRUE ? 0 : data[dataCounter] ; dataCounter++;
	
	gl_trameSize=dataCounter;

	// TRACE
	//if (gl_inputCounter==0) printf("\n\rgl_trameSize = %d dataCounter = %d",gl_trameSize,dataCounter);
}

/////////////////////////////////////////////////////////////////////////////
// getDataFromRequest 
/////////////////////////////////////////////////////////////////////////////
void getDataFromRequest(struct inputRequest* request, unsigned char* data) {

    unsigned char dataCounter=0;
	unsigned char identCounter;

	// init request
	data[dataCounter++] = request->mode;
	data[dataCounter++] = request->boardNumber ;
	data[dataCounter++] = request->globalCommand ;

	data[dataCounter++] = request->commandRequest.setGPIO ;
	data[dataCounter++] = request->commandRequest.GPIONumber ;
	data[dataCounter++] = request->commandRequest.GPIOLevel ;

	data[dataCounter++] = request->commandRequest.setLpo ;
	data[dataCounter++] = request->commandRequest.lpoNumber ;
	data[dataCounter++] = request->commandRequest.lpoLevel ;

	data[dataCounter++] = request->commandRequest.setTrack ;
	data[dataCounter++] = request->commandRequest.trackNumber ;
	data[dataCounter++] = request->commandRequest.trackSpeed ;
	data[dataCounter++] = request->commandRequest.trackDir ;

	data[dataCounter++] = request->commandRequest.setDcc ;
	data[dataCounter++] = request->commandRequest.dccAddress ;
	data[dataCounter++] = request->commandRequest.dccCommand ;

	data[dataCounter++] = request->commandRequest.getGPIOStatus ;
	data[dataCounter++] = request->commandRequest.getLpoStatus ;
	data[dataCounter++] = request->commandRequest.getTrackStatus ;
	data[dataCounter++] = request->commandRequest.getBoardStatus ;
	data[dataCounter++] = request->commandRequest.getAutomationList ;

	data[dataCounter++] = request->programRequest.setBoardMode ;
	data[dataCounter++] = request->programRequest.boardMode ;

	data[dataCounter++] = request->programRequest.setGPIO ;
	data[dataCounter++] = request->programRequest.setGPIONumber ;
	data[dataCounter++] = request->programRequest.setGPIODir ;

	data[dataCounter++] = request->programRequest.setAutomation ;

	for (identCounter=0;identCounter<MAXSIZEIDENT;identCounter++) {
		data[dataCounter++] = request->programRequest.ident[identCounter];
	}

	data[dataCounter++] = request->programRequest.GPIOEvent ;
	data[dataCounter++] = request->programRequest.eventBoardGPIONumber ;
	data[dataCounter++] = request->programRequest.eventGPIONumber ;
	data[dataCounter++] = request->programRequest.eventGPIOLevel ;

	data[dataCounter++] = request->programRequest.trackEvent ;
	data[dataCounter++] = request->programRequest.eventBoardTrackNumber ;
	data[dataCounter++] = request->programRequest.eventTrackNumber ;
	data[dataCounter++] = request->programRequest.eventVehicleStatus ;

	data[dataCounter++] = request->programRequest.GPIOSetting ;
	data[dataCounter++] = request->programRequest.actionGPIOSetNumber ;
	data[dataCounter++] = request->programRequest.actionGPIOSetLevel ;

	data[dataCounter++] = request->programRequest.lpoSetting ;
	data[dataCounter++] = request->programRequest.actionLpoSetNumber;
	data[dataCounter++] = request->programRequest.actionLpoSetLevel ;

	data[dataCounter++] = request->programRequest.trackSetting ;
	data[dataCounter++] = request->programRequest.actionTrackSetNumber ;
	data[dataCounter++] = request->programRequest.actionTrackSetSpeed ;
	data[dataCounter++] = request->programRequest.actionTrackSetDir ;

	data[dataCounter++] = request->programRequest.dccSetting ;
	data[dataCounter++] = request->programRequest.ActionDccAddressSetting ;
	data[dataCounter++] = request->programRequest.ActionDccCommandSetting ;

	data[dataCounter++] = request->programRequest.delAutomation ;
	data[dataCounter++] = request->programRequest.automationNumber ;

	data[dataCounter++] = request->eventRequest.trackEvent ;
	data[dataCounter++] = request->eventRequest.eventBoardTrackNumber ;
	data[dataCounter++] = request->eventRequest.eventTrackNumber ;
	data[dataCounter++] = request->eventRequest.eventVehicleStatus ;

	data[dataCounter++] = request->eventRequest.GPIOEvent ;
	data[dataCounter++] = request->eventRequest.eventBoardGPIONumber ;
	data[dataCounter++] = request->eventRequest.eventGPIONumber ;
	data[dataCounter++] = request->eventRequest.eventGPIOLevel ;
}

/////////////////////////////////////////////////////////////////////////////
// InitRequest 
/////////////////////////////////////////////////////////////////////////////
void initRequest(struct inputRequest* request) {	
    unsigned char init;
	init=TRUE;
	setRequest(request,gl_data,init);
}

/////////////////////////////////////////////////////////////////////////////
// printfLine 
/////////////////////////////////////////////////////////////////////////////
void printfLine() {
	unsigned char i;
	if (gl_inputCounter==0) {
		printf("\n\r");
		for(i=0;i<30;i++)printf("-");
	}
}
/////////////////////////////////////////////////////////////////////////////
// traceStructure 
/////////////////////////////////////////////////////////////////////////////
void traceStructure(struct inputRequest* request) {
 
	char true[6];
	char false[6];

    sprintf(true,"TRUE");
	sprintf(false,"FALSE"); 

	if (gl_inputCounter==0) {

	    printfLine();
		printf("\n\r(%s,%d,", 				traceValue(request->mode),
								 			request->boardNumber);
		printf("%s)", 						traceValue(request->globalCommand));
	    printfLine();
		printf("\n\rGPIO(%s,%d,%d)", 		request->commandRequest.setGPIO==TRUE ? true : false,
								  			request->commandRequest.GPIONumber,
								  			request->commandRequest.GPIOLevel);
	    printfLine();
		printf("\n\rLPO(%s,%d,%d)", 		request->commandRequest.setLpo == TRUE ? true : false,
								 			request->commandRequest.lpoNumber,
											request->commandRequest.lpoLevel);
	    printfLine();
		printf("\n\rTRACK(%s,%d,%d,%s)", 	request->commandRequest.setTrack == TRUE ? true : false,
											request->commandRequest.trackNumber,
											request->commandRequest.trackSpeed,
											traceValue(request->commandRequest.trackDir));
	    printfLine();
		printf("\n\rDCC(%s,0x%x,0x%x)", 	request->commandRequest.setDcc == TRUE ? true : false,
									 		request->commandRequest.dccAddress,
									 		request->commandRequest.dccCommand);
	    printfLine();
		printf("\n\rAUT(%s,%s,%s,%s,%s)", 	request->commandRequest.getAutomationList == TRUE ? true : false,
									   		request->commandRequest.getBoardStatus == TRUE ? true : false,
									   		request->commandRequest.getGPIOStatus == TRUE ? true : false,
											request->commandRequest.getLpoStatus == TRUE ? true : false,
									   		request->commandRequest.getTrackStatus == TRUE ? true : false);
	    printfLine();		
		printf("\n\rPROGRAM :");
	    printfLine();
		printf("\n\rMODE(%s,%s)", 			request->programRequest.setBoardMode == TRUE ? true : false, 
							  				traceValue(request->programRequest.boardMode));
	    printfLine();
		printf("\n\rGPIO(%s,%d,%s)", 		request->programRequest.setGPIO == TRUE ? true : false,
								 			request->programRequest.setGPIONumber,
								 			traceValue(request->programRequest.setGPIODir));
	    printfLine();
		printf("\n\rAUT(%s,%s)", 			request->programRequest.setAutomation == TRUE ? true : false,request->programRequest.ident);
	    printfLine();
		printf("\n\rGPIO(%s,%d,%d,%d)", 	request->programRequest.GPIOEvent == TRUE ? true : false,
								    		request->programRequest.eventBoardGPIONumber,
											request->programRequest.eventGPIONumber,
											request->programRequest.eventGPIOLevel);
	    printfLine();
		printf("\n\rTRACK(%s,%d,%d,%s)", 	request->programRequest.trackEvent == TRUE ? true : false,
								    		request->programRequest.eventBoardTrackNumber,
								    		request->programRequest.eventTrackNumber,
								    		traceValue(request->programRequest.eventVehicleStatus));
	    printfLine();
		printf("\n\rGPIO(%s,%d,%d)", 		request->programRequest.GPIOSetting == TRUE ? true : false,
								 			request->programRequest.actionGPIOSetNumber,
								 			request->programRequest.actionGPIOSetLevel);
	    printfLine();
		printf("\n\rLPO(%s,%d,%d)", 		request->programRequest.lpoSetting == TRUE ? true : false,
								 			request->programRequest.actionLpoSetNumber,
								 			request->programRequest.actionLpoSetLevel);
	    printfLine();
		printf("\n\rTRACK(%s,%d,%d,%s)", 	request->programRequest.trackSetting == TRUE ? true : false,
											request->programRequest.actionTrackSetNumber,
											request->programRequest.actionTrackSetSpeed,
											traceValue(request->programRequest.actionTrackSetDir));
	    printfLine();
		printf("\n\rDCC(%s,0x%x,0x%x)", 	request->programRequest.dccSetting == TRUE ? true : false,
								     		request->programRequest.ActionDccAddressSetting,
									 		request->programRequest.ActionDccCommandSetting);
	    printfLine();
		printf("\n\rAUT(%s,%d)", 			request->programRequest.delAutomation == TRUE ? true : false,
							  				request->programRequest.automationNumber);
	    printfLine();
		printf("\n\rEVENT :");
	    printfLine();
		printf("\n\rGPIO(%s,%d,%d,%d)", 	request->eventRequest.GPIOEvent == TRUE ? true : false,
											request->eventRequest.eventBoardGPIONumber,
											request->eventRequest.eventGPIONumber,
											request->eventRequest.eventGPIOLevel);
	    printfLine();
		printf("\n\rTRACK(%s,%d,%d,%s)", 	request->eventRequest.trackEvent == TRUE ? true : false,
											request->eventRequest.eventBoardTrackNumber,
								    		request->eventRequest.eventTrackNumber,
											traceValue(request->eventRequest.eventVehicleStatus));
	    printfLine();
	}
}

/////////////////////////////////////////////////////////////////////////////
// manageRequest 
/////////////////////////////////////////////////////////////////////////////
unsigned char manageRequest (struct inputRequest* request) {

	 unsigned char automationCounter;
	 unsigned char identCounter;
	 unsigned char eventBoardTrackNumber;
	 unsigned char eventTrackNumber;
	 unsigned char eventVehicleStatus;

	 unsigned char eventBoardGPIONumber;
	 unsigned char eventGPIONumber;
	 unsigned char eventGPIOLevel;

	 unsigned short adr; 
	 unsigned char writeEEPROMCounter;

	// TRACE
	// traceStructure(request);

	// CHECK EVENT FIRST
	if (request->eventRequest.trackEvent == TRUE) {

		// Event from this board should be sent to the others
		if (request->boardNumber == gl_boardNumber) sendRequestToCAN(request);

		// Keep values as request struct should be reset
		eventBoardTrackNumber=request->eventRequest.eventBoardTrackNumber;
		eventTrackNumber=request->eventRequest.eventTrackNumber;
		eventVehicleStatus=request->eventRequest.eventVehicleStatus;

		// TRACE
		// if (gl_inputCounter==0) printf("T(%d,%d,%s)", eventBoardTrackNumber,eventTrackNumber,traceValue(eventVehicleStatus));	

		for(automationCounter=0;automationCounter<gl_lastAutomation;automationCounter++) {
				if(gl_automation[automationCounter].automationEvent.trackEvent==TRUE) {
				if (gl_automation[automationCounter].automationEvent.eventBoardTrackNumber==eventBoardTrackNumber &&
					gl_automation[automationCounter].automationEvent.eventTrackNumber==eventTrackNumber &&
					gl_automation[automationCounter].automationEvent.eventVehicleStatus==eventVehicleStatus) {

						// set request for command
						initRequest(request);

						request->mode=COMValue;
						request->boardNumber=gl_boardNumber;
						request->commandRequest.setGPIO = gl_automation[automationCounter].automationCommand.setGPIO;
						request->commandRequest.GPIONumber = gl_automation[automationCounter].automationCommand.GPIONumber;
						request->commandRequest.GPIOLevel = gl_automation[automationCounter].automationCommand.GPIOLevel;

						request->commandRequest.setLpo = gl_automation[automationCounter].automationCommand.setLpo;
						request->commandRequest.lpoNumber = gl_automation[automationCounter].automationCommand.lpoNumber;
						request->commandRequest.lpoLevel = gl_automation[automationCounter].automationCommand.lpoLevel;

						request->commandRequest.setTrack = gl_automation[automationCounter].automationCommand.setTrack;
						request->commandRequest.trackNumber = gl_automation[automationCounter].automationCommand.trackNumber;
						request->commandRequest.trackSpeed = gl_automation[automationCounter].automationCommand.trackSpeed;
						request->commandRequest.trackDir = gl_automation[automationCounter].automationCommand.trackDir;

						request->commandRequest.setDcc = gl_automation[automationCounter].automationCommand.setDcc;
						request->commandRequest.dccAddress = gl_automation[automationCounter].automationCommand.dccAddress;
						request->commandRequest.dccCommand = gl_automation[automationCounter].automationCommand.dccCommand;

						if (manageRequest(request)==FALSE) return (FALSE);
						else continue;	
					}
				}	
			}	
			return(TRUE);
	}
	else if (request->eventRequest.GPIOEvent == TRUE) {

		// Event from this board should be sent to the others
		if (request->boardNumber == gl_boardNumber) sendRequestToCAN(request);

		// Keep values as request struct should be reset
		eventBoardGPIONumber=request->eventRequest.eventBoardGPIONumber;
		eventGPIONumber=request->eventRequest.eventGPIONumber;
		eventGPIOLevel=request->eventRequest.eventGPIOLevel;

		// TRACE
		if (gl_inputCounter==0) printf("G(%d,%d,%d)", eventBoardGPIONumber,eventGPIONumber,eventGPIOLevel);	

		for(automationCounter=0;automationCounter<gl_lastAutomation;automationCounter++) {
			if(gl_automation[automationCounter].automationEvent.GPIOEvent==TRUE) {
				if (gl_automation[automationCounter].automationEvent.eventBoardTrackNumber==eventBoardTrackNumber &&
					gl_automation[automationCounter].automationEvent.eventGPIONumber==eventGPIONumber &&
					gl_automation[automationCounter].automationEvent.eventGPIOLevel==eventGPIOLevel) {

						// set request for command
						initRequest(request);

						request->mode=COMValue;
						request->boardNumber=gl_boardNumber;
						request->commandRequest.setGPIO = gl_automation[automationCounter].automationCommand.setGPIO;
						request->commandRequest.GPIONumber = gl_automation[automationCounter].automationCommand.GPIONumber;
						request->commandRequest.GPIOLevel = gl_automation[automationCounter].automationCommand.GPIOLevel;

						request->commandRequest.setLpo = gl_automation[automationCounter].automationCommand.setLpo;
						request->commandRequest.lpoNumber = gl_automation[automationCounter].automationCommand.lpoNumber;
						request->commandRequest.lpoLevel = gl_automation[automationCounter].automationCommand.lpoLevel;

						request->commandRequest.setTrack = gl_automation[automationCounter].automationCommand.setTrack;
						request->commandRequest.trackNumber = gl_automation[automationCounter].automationCommand.trackNumber;
						request->commandRequest.trackSpeed = gl_automation[automationCounter].automationCommand.trackSpeed;
						request->commandRequest.trackDir = gl_automation[automationCounter].automationCommand.trackDir;

						request->commandRequest.setDcc = gl_automation[automationCounter].automationCommand.setDcc;
						request->commandRequest.dccAddress = gl_automation[automationCounter].automationCommand.dccAddress;
						request->commandRequest.dccCommand = gl_automation[automationCounter].automationCommand.dccCommand;

						if (manageRequest(request)==FALSE) return (FALSE);
						else continue;	
					}
				}	
			}	
			return(TRUE);
	}

	//Global command

	// TRACE
	//if (gl_inputCounter==0) printf("\n\rrequest->globalCommand = 0x%x",request->globalCommand);

    switch (request->globalCommand) {
		case STOPValue: 
			gl_stopAll=TRUE;
			if (request->boardNumber == gl_boardNumber) sendRequestToCAN(request);
			return(TRUE);
		case RUNALLValue :
			gl_stopAll=FALSE;
			if (request->boardNumber != gl_boardNumber) sendRequestToCAN(request);
			return(TRUE);
		case RUNValue :
			if (request->boardNumber != gl_boardNumber) sendRequestToCAN(request);
			else gl_stopAll=FALSE;
		 	return(TRUE); 
		case RESETValue :
			if (request->boardNumber != gl_boardNumber) sendRequestToCAN(request);
			else {
				gl_lastAutomation=0;
				adr=(unsigned int)LASTAUTOMATION_ADDRESS;
				WriteEEPROM(adr,gl_lastAutomation);
			}
		 	return(TRUE); 

		default : 

			// Check board number for command or program, on the master side, we forward the request on CAN bus
			if ((request->boardNumber != gl_boardNumber) && (IN0 & IN1 & IN2)) {

				// Send request to CAN
                sendRequestToCAN(request);
				return(TRUE);
			}

			switch(request->mode) {
			case PROGValue: 
				if (request->programRequest.setBoardMode==TRUE) {
					if(request->programRequest.boardMode==DCCValue) {
							gl_mutex=1;	setDcc(0,0); gl_mode=DCCValue; gl_mutex=0;
								
							// Save to EEPROM
							adr=(unsigned short)MODE_ADDRESS;
							WriteEEPROM(adr,gl_mode);
							return(TRUE);
					}
					else if(request->programRequest.boardMode==ANAValue) {
							gl_mutex=1; gl_mode=ANAValue; gl_mutex=0;

							// Save to EEPROM
							adr=(unsigned short)MODE_ADDRESS;
							WriteEEPROM(adr,gl_mode);
							return(TRUE);
					}
					else {
						gl_parserErrorCode=MODE_MISSING;
						return(FALSE);
					}
				}
				if (request->programRequest.setGPIO == TRUE) {		
					if (request->programRequest.setGPIODir==INValue) {		
						if (request->programRequest.setGPIONumber==0) {
							gl_mutex=1; TRISDbits.RD1 = 1; gl_mutex=0;
						}
						else if (request->programRequest.setGPIONumber==1) {
							gl_mutex=1; TRISDbits.RD2 = 1; gl_mutex=0;
						}
						else if (request->programRequest.setGPIONumber==2) {
							gl_mutex=1; TRISDbits.RD3 = 1; gl_mutex=0;
						}
						else if (request->programRequest.setGPIONumber==3) {
							gl_mutex=1; TRISCbits.RC4 = 1; gl_mutex=0;
						}
						else {
							gl_parserErrorCode=BAD_GPIO_NUMBER;
							return(FALSE);
						}	
						return(TRUE);
					}
					else if (request->programRequest.setGPIODir==OUTValue) {
						if (request->programRequest.setGPIONumber==0) {
							gl_mutex=1; TRISDbits.RD1 = 0; gl_mutex=0;
						}
						else if (request->programRequest.setGPIONumber==1) {
							gl_mutex=1; TRISDbits.RD2 = 0; gl_mutex=0;
						}
						else if (request->programRequest.setGPIONumber==2) {
							gl_mutex=1; TRISDbits.RD3 = 0; gl_mutex=0;
						}
						else if(request->programRequest.setGPIONumber==3) {
							gl_mutex=1; TRISCbits.RC4 = 0; gl_mutex=0;
						}
						else {
							gl_parserErrorCode=BAD_GPIO_NUMBER;
							return(FALSE);
						}	
						return(TRUE);
					}
					else {
						gl_parserErrorCode=BAD_GPIO_DIR;
						return(FALSE);
					}											
				}
				if (request->programRequest.setAutomation == TRUE) {
					if (gl_lastAutomation>=MAXAUTOMATION) {
						gl_parserErrorCode=AUTOMATIONSIZELIMIT;
						return(FALSE);
					}			


					// set new automation	
					adr=(unsigned short)AUTOMATION_ADDRESS+gl_lastAutomation*gl_trameSize;

					// TRACE
					//if (gl_inputCounter==0) printf("\n\radr = %d gl_lastAutomation = %d  gl_trameSize = %d",adr,gl_lastAutomation,gl_trameSize);
					
					// save to EEPROM
					
					for (identCounter=0;identCounter<MAXSIZEIDENT;identCounter++) {
						WriteEEPROM(adr++,request->programRequest.ident[identCounter]);
					}
					WriteEEPROM(adr++,request->programRequest.trackEvent);
					WriteEEPROM(adr++,request->programRequest.eventBoardTrackNumber);
					WriteEEPROM(adr++,request->programRequest.eventTrackNumber);
					WriteEEPROM(adr++,request->programRequest.eventVehicleStatus);

					WriteEEPROM(adr++,request->programRequest.GPIOEvent);
					WriteEEPROM(adr++,request->programRequest.eventBoardGPIONumber);
					WriteEEPROM(adr++,request->programRequest.eventGPIONumber);
					WriteEEPROM(adr++,request->programRequest.eventGPIOLevel);

					WriteEEPROM(adr++,request->programRequest.GPIOSetting);
					WriteEEPROM(adr++,request->programRequest.actionGPIOSetNumber);
					WriteEEPROM(adr++,request->programRequest.actionGPIOSetLevel);

					WriteEEPROM(adr++,request->programRequest.lpoSetting);
					WriteEEPROM(adr++,request->programRequest.actionLpoSetNumber);
					WriteEEPROM(adr++,request->programRequest.actionLpoSetLevel);

					WriteEEPROM(adr++,request->programRequest.trackSetting);
					WriteEEPROM(adr++,request->programRequest.actionTrackSetNumber);
					WriteEEPROM(adr++,request->programRequest.actionTrackSetSpeed);
					WriteEEPROM(adr++,request->programRequest.actionTrackSetDir);

					WriteEEPROM(adr++,request->programRequest.dccSetting);
					WriteEEPROM(adr++,request->programRequest.ActionDccAddressSetting);
					WriteEEPROM(adr++,request->programRequest.ActionDccCommandSetting);

					for(writeEEPROMCounter=0;writeEEPROMCounter<5;writeEEPROMCounter++)	WriteEEPROM(adr++,0);

					gl_lastAutomation++;
					adr=(unsigned short)LASTAUTOMATION_ADDRESS;
					WriteEEPROM(adr,gl_lastAutomation);

					// Update form EEPROM
					ReadEEPROMConfig();

					// TRACE
					// if (gl_inputCounter==0) printf("\n\rafter readEEPROM gl_lastAutomation = %d",gl_lastAutomation);					

					return(TRUE);
				}		

				break;
				
			case COMValue : 
				if (request->commandRequest.setGPIO==TRUE) {
					if (request->commandRequest.GPIONumber==0) {
						if (TRISDbits.RD1==1) {
							gl_parserErrorCode=CANT_SET_GPIO_IN_INPUT_MODE;
							return(FALSE);
						}
						else {
							if (request->commandRequest.GPIOLevel==0) {
								gl_mutex=1;	gl_GPIOchar[0]=0; gl_mutex=0;
								return(TRUE);
							}
							else if (request->commandRequest.GPIOLevel==1) {
								gl_mutex=1;	gl_GPIOchar[0]=1; gl_mutex=0;
								return(TRUE);
							}
							else {
								gl_parserErrorCode=BAD_GPIO_LEVEL;
								return(FALSE);
							}
						}
					}
					else if (request->commandRequest.GPIONumber==1) {
						if (TRISDbits.RD2==1) {
							gl_parserErrorCode=CANT_SET_GPIO_IN_INPUT_MODE;
							return(FALSE);
						}
						else {
							if (request->commandRequest.GPIOLevel==0) {
								gl_mutex=1;	gl_GPIOchar[1]=0; gl_mutex=0;
								return(TRUE);
							}
							else if (request->commandRequest.GPIOLevel==1) {
								gl_mutex=1;	gl_GPIOchar[1]=1; gl_mutex=0;
								return(TRUE);
							}
							else {
								gl_parserErrorCode=BAD_GPIO_LEVEL;
								return(FALSE);
							}
						}
					}
					else if (request->commandRequest.GPIONumber==2) {
						if (TRISDbits.RD3==1) {
							gl_parserErrorCode=CANT_SET_GPIO_IN_INPUT_MODE;
							return(FALSE);
						}
						else {
							if (request->commandRequest.GPIOLevel==0) {
								gl_mutex=1;	gl_GPIOchar[2]=0; gl_mutex=0;
								return(TRUE);
							}
							else if (request->commandRequest.GPIOLevel==1) {
								gl_mutex=1;	gl_GPIOchar[2]=1; gl_mutex=0;
								return(TRUE);
							}
							else {
								gl_parserErrorCode=BAD_GPIO_LEVEL;
								return(FALSE);
							}
						}
					}
					else if (request->commandRequest.GPIONumber==3) {
						if (TRISCbits.RC4==1) {
							gl_parserErrorCode=CANT_SET_GPIO_IN_INPUT_MODE;
							return(FALSE);
						}
						else {
							if (request->commandRequest.GPIOLevel==0) {
								gl_mutex=1;	gl_GPIOchar[3]=0; gl_mutex=0;
								return(TRUE);
							}
							else if (request->commandRequest.GPIOLevel==1) {
								gl_mutex=1;	gl_GPIOchar[3]=1; gl_mutex=0;
								return(TRUE);
							}
							else {
								gl_parserErrorCode=BAD_GPIO_LEVEL;
								return(FALSE);
							}
						}
					}	
					else {
						gl_parserErrorCode=BAD_GPIO_NUMBER;
						return(FALSE);
					}			
				}
				else if (request->commandRequest.setLpo == TRUE) {
						if (request->commandRequest.lpoNumber==0) {
							if(request->commandRequest.lpoLevel==0) {
								gl_mutex=1;gl_OUTchar[0]=1;gl_mutex=0;
								return(TRUE);
							}
							else if(request->commandRequest.lpoLevel==1) {
								gl_mutex=1;gl_OUTchar[0]=0;gl_mutex=0;
								return(TRUE);
							}
							else {
								gl_parserErrorCode=BAD_LPO_LEVEL;
								return(FALSE);
							}
						}
						else if (request->commandRequest.lpoNumber==1) {
							if(request->commandRequest.lpoLevel==0) {
								gl_mutex=1;gl_OUTchar[1]=1;gl_mutex=0;
								return(TRUE);
							}
							else if(request->commandRequest.lpoLevel==1) {
								gl_mutex=1;gl_OUTchar[1]=0;gl_mutex=0;
								return(TRUE);
							}
							else {
								gl_parserErrorCode=BAD_LPO_LEVEL;
								return(FALSE);
							}
						}
						else if (request->commandRequest.lpoNumber==2) {
							if(request->commandRequest.lpoLevel==0) {
								gl_mutex=1;gl_OUTchar[2]=1;gl_mutex=0;
								return(TRUE);
							}
							else if(request->commandRequest.lpoLevel==1) {
								gl_mutex=1;gl_OUTchar[2]=0;gl_mutex=0;
								return(TRUE);
							}
							else {
								gl_parserErrorCode=BAD_LPO_LEVEL;
								return(FALSE);
							}
						}
						else if (request->commandRequest.lpoNumber==3) {
							if(request->commandRequest.lpoLevel==0) {
								gl_mutex=1;gl_OUTchar[3]=1;gl_mutex=0;
								return(TRUE);
							}
							else if(request->commandRequest.lpoLevel==1) {
								gl_mutex=1;gl_OUTchar[3]=0;gl_mutex=0;
								return(TRUE);
							}
							else {
								gl_parserErrorCode=BAD_LPO_LEVEL;
								return(FALSE);
							}
						}
						else if (request->commandRequest.lpoNumber==4) {
							if(request->commandRequest.lpoLevel==0) {
								gl_mutex=1;gl_OUTchar[4]=1;gl_mutex=0;
								return(TRUE);
							}
							else if(request->commandRequest.lpoLevel==1) {
								gl_mutex=1;gl_OUTchar[4]=0;gl_mutex=0;
								return(TRUE);
							}
							else {
								gl_parserErrorCode=BAD_LPO_LEVEL;
								return(FALSE);
							}
						}
						else if (request->commandRequest.lpoNumber==5) {
							if(request->commandRequest.lpoLevel==0) {
								gl_mutex=1;gl_OUTchar[5]=1;gl_mutex=0;
								return(TRUE);
							}
							else if(request->commandRequest.lpoLevel==1) {
								gl_mutex=1;gl_OUTchar[5]=0;gl_mutex=0;
								return(TRUE);
							}
							else {
								gl_parserErrorCode=BAD_LPO_LEVEL;
								return(FALSE);
							}
						}
						else {
							gl_parserErrorCode=BAD_LPO_NUMBER;
							return(FALSE);
						}
				}
				else if (request->commandRequest.setTrack == TRUE) {
						if (gl_mode==DCCValue) {
							gl_parserErrorCode=BAD_MODE;
							return(FALSE);
						}
													
						if (request->commandRequest.trackNumber>=0 && request->commandRequest.trackNumber<=4) {
							if ((request->commandRequest.trackSpeed>=0 && request->commandRequest.trackSpeed<=15) &&
							    (request->commandRequest.trackDir==FORWValue || request->commandRequest.trackDir==BACKValue)) {
								gl_mutex=1;
								if (request->commandRequest.trackNumber==4) { // ALL
									for(request->commandRequest.trackNumber=0;request->commandRequest.trackNumber<4;request->commandRequest.trackNumber++) {
										gl_setPoint[request->commandRequest.trackNumber]=request->commandRequest.trackSpeed * ACC_RATE;
										if (request->commandRequest.trackDir==BACKValue) gl_setPoint[request->commandRequest.trackNumber]=-gl_setPoint[request->commandRequest.trackNumber];
									}
								}
								else {
										gl_setPoint[request->commandRequest.trackNumber]=request->commandRequest.trackSpeed * ACC_RATE;
										if (request->commandRequest.trackDir==BACKValue) gl_setPoint[request->commandRequest.trackNumber]=-gl_setPoint[request->commandRequest.trackNumber];
								}
								gl_mutex=0;
								return(TRUE);
							}
							else {
								if (!(request->commandRequest.trackSpeed>=0 && request->commandRequest.trackSpeed<=15)) {
									gl_parserErrorCode=BAD_TRACK_SPEED;
									return(FALSE);
								}
								if (!(request->commandRequest.trackDir==FORWValue || request->commandRequest.trackDir==BACKValue)) {
									gl_parserErrorCode=BAD_TRACK_DIR;
									return(FALSE);
								}
							}	
						}
						else {								
							gl_parserErrorCode=BAD_TRACK_NUMBER;
							return(FALSE);
						}
				}
				else if (request->commandRequest.setDcc == TRUE) {
						if (gl_mode==ANAValue) {
							gl_parserErrorCode=BAD_MODE;
							return(FALSE);
						}
						gl_mutex=1;
						setDcc(request->commandRequest.dccAddress,request->commandRequest.dccCommand);
						gl_mutex=0;

						return(TRUE);
				}
				else if (request->commandRequest.getAutomationList == TRUE) {
					for(automationCounter=0;automationCounter<gl_lastAutomation;automationCounter++) {
						if (gl_inputCounter==0) printf("\n\r%s",gl_automation[automationCounter].ident);
					}
					return(TRUE);
				}
				else if (request->commandRequest.getBoardStatus == TRUE) {
						// TRACE
						//if (gl_inputCounter==0) printf("\n\rmode = %s", traceValue(gl_mode));
						return(TRUE);
				}
				else if (request->commandRequest.getGPIOStatus == TRUE) {
						// TODO
						return(TRUE);
				}
				else if (request->commandRequest.getLpoStatus == TRUE) {
						// TODO
						return(TRUE);
				}
				else if (request->commandRequest.getTrackStatus == TRUE) {
						// TODO
						return(TRUE);
				}
					else {
						// TODO ERROR MESSAGE
						return(FALSE);
					}
				
				break;

			// UNKNOWN ERROR
			default : 
				gl_parserErrorCode=UNKNOWN_ERROR;
				return(FALSE);
		}
	}
}

//////////////////////////////////////////////////////////////////////////////
// UART
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// initUSART
//////////////////////////////////////////////////////////////////////////////
void initUSART() {

 	unsigned char 	readUSARTPointer;

    //RX and TX pin configuration
	TRISC=0b10110000; //  RC4, RC5, RC7 (RX) in (RC6 TX RS232 out, could be updated as standard GPIO in initSignal())

    // USART module configuration
    TXSTAbits.TXEN = 1; // Activate USART transmitter
    TXSTAbits.SYNC = 0; // Asynchronous mode
    TXSTAbits.BRGH = 1; // High Baud Rate Select bit
    RCSTAbits.SPEN = 1; // Enable serial module (TX and RX)
    RCSTAbits.CREN = 1; // Enable USART receiver
   
    // Speed register configuration
    SPBRG = ((_XTAL_FREQ / 16) / _BAUD) - 1; // _BAUD defined in main.h

	// init RS232 input buffer, event if it's not mandatory at all
	for(readUSARTPointer=0;readUSARTPointer<USARTBUFFERSIZE;readUSARTPointer++) {
		gl_receivedUSARTData[readUSARTPointer]=0;
	}
	gl_receivedUSARTPointer=0;
	gl_getDataUSARTPointer=0;

    PIE1bits.RCIE = 1;      // Enable USART interrupt reception
}
/*****************************************************************************/
/* sendUSART */
/*****************************************************************************/
void sendUSART(unsigned char data){

    // wait until transmission buffer is empty
    while (!TXSTAbits.TRMT);
	TXREG = data;
	while(!PIR1bits.TXIF);
}
/*****************************************************************************/
/* getInputRequestFromUSART() */
/*****************************************************************************/
unsigned char getInputRequestFromUSART(unsigned char *inputString,char* inputCounter) {

   unsigned char  getData;

	// Get Data from RS232
	if (gl_getDataUSARTPointer!=gl_receivedUSARTPointer) {
		getData=gl_receivedUSARTData[gl_getDataUSARTPointer];
		gl_receivedUSARTData[gl_getDataUSARTPointer++] = 0;

		if (gl_getDataUSARTPointer>=USARTBUFFERSIZE)gl_getDataUSARTPointer=0;

		//Echo
        if (getData!=0xD && *inputCounter<MAXINPUTSTRING-1) {
		
			if (getData==0x7F) {
				(*inputCounter)--;
				if (*inputCounter<0) *inputCounter=0;
				else _usart_putc(getData); // Echo
			}
			else {
                inputString[(*inputCounter)++]=(unsigned char)toUpperCase(getData);
				_usart_putc(getData); // Echo
			}
       }
        else {
			inputString[*inputCounter]='\0';	
			return(TRUE);
		}
	}
	else {
		return(FALSE);
	}	
}
//////////////////////////////////////////////////////////////////////////////
// CAN
//////////////////////////////////////////////////////////////////////////////
/*****************************************************************************/
/* _user_putc() */
/*****************************************************************************/
int _user_putc (char c) {

	 unsigned long 	id;			// Id of sender
     unsigned char 	dataOut[8];	// DATA to CAN	
	 unsigned char 	dataCounter;
	 unsigned char	dataOutCounter;
	BYTE dataLen; 				// Number of bytes transmitted in the message
	ECAN_RX_MSG_FLAGS flags; 	// Flags


	// On master board send to UART via standart putc()
	if (IN0 & IN1 & IN2){
		putc(c);
	}
	else {
		// Send on CAN bus
		if (c=='\r' || gl_outputBufferCounter==gl_trameSize) {

			dataLen=8;
			flags=ECAN_TX_STD_FRAME;
			dataCounter=0;

			// break trame
			for(dataOutCounter=0;dataOutCounter<8;dataOutCounter++) {
				dataOut[dataOutCounter]=0xFE;
			}
			while(!ECANSendMessage(id,dataOut,dataLen,flags));

			// trame
			while(dataCounter<gl_trameSize) {
				for(dataOutCounter=0;dataOutCounter<8;dataOutCounter++) {
					if (dataCounter<gl_outputBufferCounter) {
						dataOut[dataOutCounter]=gl_outputBuffer[dataCounter++];
					}
					else {
						dataOut[dataOutCounter]=0;
					}
				}
				while(!ECANSendMessage(id,dataOut,dataLen,flags));
			}
			gl_outputBufferCounter=0;
		}
		else {
			gl_outputBuffer[gl_outputBufferCounter++]=c;

		}
	}
	return(c);
}

/*****************************************************************************/
/* sendRequestToCAN() */
/*****************************************************************************/
void sendRequestToCAN(struct inputRequest* request) {
	
	 unsigned long 	id;			// Id of sender
     unsigned char 	dataOut[8];	// DATA to CAN	
	 unsigned char 	dataCounter;
	 unsigned char	dataOutCounter;
	BYTE dataLen; 				// Number of bytes transmitted in the message
	ECAN_RX_MSG_FLAGS flags; 	// Flags

	// Convert request to dataOut using gl_data
	getDataFromRequest(request,gl_data);

	dataLen=8;
	flags=ECAN_TX_STD_FRAME;
	dataCounter=0;
	id=gl_boardNumber;

	// break trame
	for(dataOutCounter=0;dataOutCounter<8;dataOutCounter++) {
		dataOut[dataOutCounter]=0xFF;
	}
	while(!ECANSendMessage(id,dataOut,dataLen,flags));

	// trame
	while(dataCounter<gl_trameSize) {
		for(dataOutCounter=0;dataOutCounter<8;dataOutCounter++) {
			if (dataCounter<gl_trameSize) {
				dataOut[dataOutCounter]=gl_data[dataCounter++];
			}
			else {
				dataOut[dataOutCounter]=0;
			}
		}
		while(!ECANSendMessage(id,dataOut,dataLen,flags));
	}
}
/*****************************************************************************/
/* getInputRequestFromCAN() */
/*****************************************************************************/
unsigned char getInputRequestFromCAN(struct inputRequest* request) {
	
	 unsigned long 	id;			// Id of sender
     unsigned char 	dataIn[8];	// DATA from CAN	    	
	 unsigned char 	dataInCounter;
	 unsigned char	breakRequestTrameDetected;
	 unsigned char	breakPrintfTrameDetected;
	 unsigned char 	init;
	BYTE dataLen; 				// Number of bytes transmitted in the message
	ECAN_RX_MSG_FLAGS flags; 	// Flags

	while(ECANReceiveMessage(&id, dataIn, &dataLen, &flags)) {
		breakRequestTrameDetected=0;
		breakPrintfTrameDetected=0;
		for(dataInCounter=0;dataInCounter<8;dataInCounter++) {
			if (dataIn[dataInCounter]==0xFF) breakRequestTrameDetected++;
			else if (dataIn[dataInCounter]==0xEE) breakPrintfTrameDetected++;
			if (gl_dataInCounter<gl_trameSize) {
				gl_data[gl_dataInCounter++]=dataIn[dataInCounter];
			}
		}
		if (breakRequestTrameDetected==8) {
			gl_dataInCounter=0;	
			gl_canMode=CAN_REQUEST;	
			return(FALSE); // Mean no request available
		}
		else if (breakPrintfTrameDetected==8) {
			gl_dataInCounter=0;	
			gl_canMode=CAN_PRINTF;	
			return(FALSE); // Mean no request available
		}
		if (gl_dataInCounter>=gl_trameSize && gl_canMode==CAN_REQUEST) {
			init=FALSE;
			setRequest(request,gl_data,init);
			gl_dataInCounter=0;
			return(TRUE); // Mean request available
		}
		else if (gl_dataInCounter>=gl_trameSize && gl_canMode==CAN_PRINTF) {
			init=FALSE;
			printf("%s",gl_data);
			gl_dataInCounter=0;
			return(FALSE); // Mean no request available because in printf mode		
		}
	}

	return(FALSE); // Mean no request available
}
//////////////////////////////////////////////////////////////////////////////
// INTERRUPT AND SIGNAL MANAGEMENT
//////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// setDcc
/////////////////////////////////////////////////////////////////////////////
void setDcc(unsigned char address, unsigned char command) {

	 unsigned char i;			
	 unsigned char bitNumber; 	
	 unsigned char control; 		

	control=address ^ command; // Control
	bitNumber=0;

	// PREAMBULE
    for(i=0;i<PREAMBLE_SIZE;i++) {
		gl_dcc[bitNumber++]=1;
	}
	// 0
	gl_dcc[bitNumber++]=0;

	// ADDRESS
    for(i=0;i<8;i++) {
		gl_dcc[bitNumber++]=address >> (7-i) & 1;
	}
	// 0
	gl_dcc[bitNumber++]=0;

	// COMMAND
    for(i=0;i<8;i++) {
		gl_dcc[bitNumber++]=command >> (7-i) & 1;
	}
	// 0
	gl_dcc[bitNumber++]=0;

	// CONTROL
    for(i=0;i<8;i++) {
		gl_dcc[bitNumber++]=control >> (7-i) & 1;
	}
	// 1
	gl_dcc[bitNumber++]=1;			
	gl_dcc[bitNumber++]=1; // Only one is enough, but in case of....
}

//////////////////////////////////////////////////////////////////////////////
// function SetPort
//////////////////////////////////////////////////////////////////////////////
void setPort(){

    unsigned char OUTCounter;
	unsigned char myPortA; // used to better synchronised output updates
	unsigned char myPortB; // used to better synchronised output updates
	unsigned char myPortC; // used to better synchronised output updates
	unsigned char myPortD; // used to better synchronised output updates
	unsigned char myPortE; // used to better synchronised output updates

	if (gl_stopAll==TRUE) {
		gl_S1T0char=0; gl_S2T0char=0;
		gl_S1T1char=0; gl_S2T1char=0;
		gl_S1T2char=0; gl_S2T2char=0;
		gl_S1T3char=0; gl_S2T3char=0;	
		for(OUTCounter=0;OUTCounter<6;OUTCounter++) gl_OUTchar[OUTCounter]=1;
	}

    myPortA=(gl_S1T0char<<4)+(gl_S2T0char<<7)+ (gl_OUTSTATchar[0]<<5)+(gl_S1T1char<<6);
    myPortB=(gl_OUTchar[2]) + (gl_OUTchar[3]<<1) + (gl_OUTchar[4]<<4) + (gl_OUTchar[5]<<5);
	myPortC=(gl_S2T1char) + (gl_S1T2char<<1) + (gl_S2T2char<<2) + (gl_S1T3char<<3) +(TRISCbits.RC4==0 ? gl_GPIOchar[3] <<4 : 0);
	myPortD=(gl_S2T3char) + (TRISDbits.RD1==0 ? gl_GPIOchar[0] <<1:0) + (TRISDbits.RD2==0 ? gl_GPIOchar[1] <<2:0) +(TRISDbits.RD3==0 ? gl_GPIOchar[2] <<3:0) +  (gl_OUTchar[0]<<6) +  (gl_OUTchar[1]<<7);
    myPortE=(gl_OUTSTATchar[1]) + (gl_OUTSTATchar[2]<<1) + (gl_OUTSTATchar[3]<<2);

	LATA=myPortA;
    LATB=myPortB;
    LATC=myPortC;
    LATD=myPortD;
    LATE=myPortE;
}

//////////////////////////////////////////////////////////////////////////////
// function EnableGlobalInterrupt()
//////////////////////////////////////////////////////////////////////////////
void EnableGlobalInterrupt() {

	INTCONbits.GIE = 1;
	INTCONbits.PEIE = 1;
	INTCON3bits.INT1IE= 0;
	INTCON3bits.INT2IE= 0;
}

//////////////////////////////////////////////////////////////////////////////
// function DisableGlobalInterrupt()
//////////////////////////////////////////////////////////////////////////////
void DisableGlobalInterrupt() {

	INTCONbits.GIE = 0;
	INTCONbits.PEIE = 0;
}
/*****************************************************************************/
/* interrupt_at_high_vector */
/*****************************************************************************/
#pragma code high_vector=0x08
void interrupt_at_high_vector(void){
    _asm goto high_isr _endasm
}
#pragma code
/****************************************************************************/
/* high_isr */
/****************************************************************************/
#pragma interrupt high_isr
void high_isr(void){
    // Check if interrupt originates from USART reception
    if (PIR1bits.RCIF)
    {
        // Read received data
        gl_receivedUSARTData[gl_receivedUSARTPointer++] = RCREG;
		if (gl_receivedUSARTPointer>=USARTBUFFERSIZE)gl_receivedUSARTPointer=0;
    }
}
#pragma code
/*****************************************************************************/
/* low_interrupt */
/*****************************************************************************/
#pragma code low_vector=0x18
void low_interrupt (){
    _asm goto low_isr _endasm
}
#pragma code
/*****************************************************************************/
/* low_isr */
/*****************************************************************************/
#pragma interruptlow low_isr
void low_isr(void){
	  unsigned char 	trackNumber;
	  unsigned char 	delay;
	  unsigned char 	selectBitDelay;
	  unsigned char 	bitNumber;
	  unsigned char 	bitValue;
	  unsigned short 	ADC;
	  int				calculNewSpeed;

	if (!gl_mutex) {

		/********** MODE ANALOG **********/
		if(gl_mode==ANAValue && gl_stopAll==FALSE) {
			gl_speedCounter++;
			if (gl_speedCounter>MAX_STEP_COUNTER) {
		 		gl_speedCounter=1;
			}

			for (trackNumber=0;trackNumber<4;trackNumber++) {

				if (gl_curSpeed[trackNumber]>gl_setPoint[trackNumber]) {
					gl_curSpeed[trackNumber]--;
				}
				else if (gl_curSpeed[trackNumber]<gl_setPoint[trackNumber]) {
					gl_curSpeed[trackNumber]++;
				}
										
				if (gl_curSpeed[trackNumber]>0) {
					calculNewSpeed = gl_curSpeed[trackNumber]/ACC_RATE;		
					gl_speed[trackNumber]=(unsigned char) calculNewSpeed;
					gl_direction[trackNumber]=TRACK_FORWARD;
				}
				else if (gl_curSpeed[trackNumber]<0) {
					calculNewSpeed = gl_curSpeed[trackNumber]/ACC_RATE;
					calculNewSpeed=-calculNewSpeed;			
					gl_speed[trackNumber]=(unsigned char)calculNewSpeed;
					gl_direction[trackNumber]=TRACK_BACKWARD;
				}
				else gl_direction[trackNumber]==TRACK_STOP;

				if (gl_speed[trackNumber]>=gl_speedCounter) {
					if (gl_direction[trackNumber]==TRACK_FORWARD) {
			    		switch (trackNumber) {
			           		case 0:gl_S1T0char=1; gl_S2T0char=0;break;
			          	 	case 1:gl_S1T1char=1; gl_S2T1char=0;break;
			           	 	case 2:gl_S1T2char=1; gl_S2T2char=0;break;
			           		case 3:gl_S1T3char=1; gl_S2T3char=0;break;
			        	}
			    	}
			    	if (gl_direction[trackNumber]==TRACK_BACKWARD) {
			        	switch (trackNumber) {
			            	case 0:gl_S1T0char=0; gl_S2T0char=1;break;
			            	case 1:gl_S1T1char=0; gl_S2T1char=1;break;
			            	case 2:gl_S1T2char=0; gl_S2T2char=1;break;
			            	case 3:gl_S1T3char=0; gl_S2T3char=1;break;
			        	}
			    	}
			    	if (gl_direction[trackNumber]==TRACK_STOP) {
			        	switch (trackNumber) {
			            	case 0:gl_S1T0char=0; gl_S2T0char=0;break;
			            	case 1:gl_S1T1char=0; gl_S2T1char=0;break;
			            	case 2:gl_S1T2char=0; gl_S2T2char=0;break;
			            	case 3:gl_S1T3char=0; gl_S2T3char=0;break;
			        	}
			    	}
				}
				else {
					switch (trackNumber) {
			        	case 0:gl_S1T0char=0; gl_S2T0char=0;break;
			        	case 1:gl_S1T1char=0; gl_S2T1char=0;break;
			        	case 2:gl_S1T2char=0; gl_S2T2char=0;break;
			        	case 3:gl_S1T3char=0; gl_S2T3char=0;break;
			    	}
				}
			} 
			setPort();
		}

		/********** MODE DIGITAL **********/
		if(gl_mode==DCCValue && gl_dcc_ready==0 && gl_stopAll==FALSE) {
			for (trackNumber=0;trackNumber<FRAME_SIZE;trackNumber++) {
				if (gl_dcc[trackNumber]==0) selectBitDelay=DCC_0;
				else selectBitDelay=DCC_1;
							
				gl_S1T0char=0;gl_S1T1char=0;
				gl_S1T2char=0;gl_S1T3char=0;
				gl_S2T0char=1;gl_S2T1char=1;
				gl_S2T2char=1;gl_S2T3char=1;
            	setPort();
				for (delay=0;delay<selectBitDelay;delay++);
	
		    	gl_S2T0char=0;gl_S2T1char=0;
				gl_S2T2char=0;gl_S2T3char=0;
				gl_S1T0char=1;gl_S1T1char=1;
				gl_S1T2char=1;gl_S1T3char=1;
            	setPort();
				for (delay=0;delay<selectBitDelay;delay++);
			}

			gl_S1T0char=0; gl_S2T0char=1;	
			gl_S1T1char=0; gl_S2T1char=1;
			gl_S1T2char=0; gl_S2T2char=1;	
			gl_S1T3char=0; gl_S2T3char=1;
        	setPort();
			for (delay=0;delay<selectBitDelay;delay++);	

		}
		gl_dcc_ready--;
		if (gl_dcc_ready<0) gl_dcc_ready=INITWAITDCCCOUNTER;
		setPort();

		// TRACK DETECTION 
		for (trackNumber=0;trackNumber<4;trackNumber++) {		
			switch(trackNumber) {
				case 0 : ADCON0=CURT0;break;
		    	case 1 : ADCON0=CURT1;break;
		    	case 2 : ADCON0=CURT2;break;
		   		case 3 : ADCON0=CURT3;break;
			}
			// NEED TO GET LOW VOLTAGE VALUE WHEN TRACK IS OFF FOR CALIBRATION AT POWER ON
	 		if (gl_calibration==TRUE) {
				ADCON0bits.GO = 1;                            // ADCON0.GODONE = 1 
				while(ADCON0bits.GO == 1);                    // wait till GODONE bit is zero
				ADC = 0;
				ADC = ADRESH;    //Read converted result 
				ADC = (ADC<<8) + ADRESL;
				gl_average[trackNumber]=(SAMPLEFORCALIBRATION*gl_average[trackNumber]+ADC)/(SAMPLEFORCALIBRATION+1);
				if (gl_noVehicule[trackNumber]>gl_average[trackNumber])gl_noVehicule[trackNumber]=gl_average[trackNumber];
			}

			if((gl_speed[trackNumber]==gl_speedCounter && gl_mode==ANAValue) || (gl_dcc_ready==INITWAITDCCCOUNTER && gl_mode==DCCValue)) { // ONLY WHEN POWER ON
				ADCON0bits.GO = 1;                            // ADCON0.GODONE = 1 
				while(ADCON0bits.GO == 1);                    // wait till GODONE bit is zero
				ADC = 0;
				ADC = ADRESH;    //Read converted result 
				ADC = (ADC<<8) + ADRESL;

				if (gl_average[trackNumber]<ADC) gl_average[trackNumber]=ADC; // TRAP THE EVENT
				else gl_average[trackNumber]=(SAMPLEFORAVERAGE*gl_average[trackNumber]+ADC)/(SAMPLEFORAVERAGE+1);

				if ((10*gl_average[trackNumber]>(10+HYSTERERISHIGH)*gl_noVehicule[trackNumber]) && (gl_OUTSTATchar[trackNumber]==0)  && (gl_trackNotification[trackNumber]==FALSE)) {
					gl_OUTSTATchar[trackNumber]=1;
					gl_trackNotification[trackNumber]=TRUE;
				}
				else if ((10*gl_average[trackNumber]<(10+HYSTERERISLOW)*gl_noVehicule[trackNumber]) && (gl_OUTSTATchar[trackNumber]==1) && (gl_trackNotification[trackNumber]==FALSE)) {
					gl_OUTSTATchar[trackNumber]=0;
					gl_trackNotification[trackNumber]=TRUE;
				}
			}
		}
	}

    // INTERRUPT RESET
    if(INTCONbits.TMR0IF==1){
	    INTCONbits.TMR0IF = 0;
		T0CONbits.PSA			= 0;   // Timer0 prescaler is assigned
		T0CONbits.T0PS0			= 0;   // Prescale value 
		T0CONbits.T0PS1			= 0;   // Prescale value 
		T0CONbits.T0PS2			= 0;   // Prescale value 
    }
}
#pragma code

//////////////////////////////////////////////////////////////////////////////
// CODE INITIALISATION
//////////////////////////////////////////////////////////////////////////////

/*****************************************************************************/
/* initSignal */
/*****************************************************************************/
void initSignal() {

    unsigned char trackNumber;
	unsigned char OUTCounter;
	unsigned char init;

	gl_mutex=1; // should not be necessary because interrupt not yet enabled

    ADCON1 = 0x0B; // AN0 to AN3 
    ADCON2 = 0x9D; 
	TRISA = 0b00001111; // PORTA AN0 to AN3 in 

    TRISB=0; // All out
    PORTB=0;
	LATB=0;

    TRISC=0b11110000; //  RC4, RC6, RC5, RC7 (RX) in (RC6 TX RS232 could be updated in initUSART() to be out)
    PORTC=0;
	LATC=0;

    TRISE=0; // All out + PORTD setting
    PORTE=0;
	LATE=0;
	CMCON = 0;

    TRISD=0b00111110; //  RD1, RD2, RD3, RD4, RD5 in
    PORTD=0;
	ECCP1CON = 0; // Disable ENHANCED CAPTURE/COMPARE/PWM (ECCP1) MODULE
	LATD=0;


    for(trackNumber=0;trackNumber<4;trackNumber++) {
      gl_average[trackNumber]=0;
	  gl_noVehicule[trackNumber]=0xFF;
      gl_speed[trackNumber]=0;
      gl_direction[trackNumber]=0;
      gl_setPoint[trackNumber]=0;
      gl_curSpeed[trackNumber]=0;
	  gl_OUTSTATchar[trackNumber]=0;
	  gl_trackNotification[trackNumber]=FALSE;
    }

	for(OUTCounter=0;OUTCounter<6;OUTCounter++) gl_OUTchar[OUTCounter]=1;

	// DCC TEMPO BETWEEN TWO TRAMES
    gl_dcc_ready=INITWAITDCCCOUNTER;

	// Start
	gl_calibration=FALSE;
	gl_stopAll=FALSE;
	gl_mutex=0;

	// Get board number
	if (IN0 & IN1 & IN2) {
		gl_boardNumber=IN0 + 2 * IN1 + 4 * IN2 + 8; // setting for master !
	}
	else {
		gl_boardNumber=IN0 + 2 * IN1 + 4 * IN2 + 8 + IN3 * 16 + IN4 * 32;
	}

	// Init structure and get trame size (gl_trameSize)
	init=TRUE;
	gl_trameSize=0;
	setRequest(&gl_request,gl_data,init);

	// Update form EEPROM
	ReadEEPROMConfig();

}

/*****************************************************************************/
/* PIC18FMainSettings */
/*****************************************************************************/
void PIC18FMainSettings (){

    // PIC setting and enable interrupts
    OSCCON                  = 0x70;  // no pre-divider => 8MHz 
    OSCTUNE                 = 0x40;  // PLL *4 => 32MHz 

    T0CONbits.T08BIT        = 1;   // 8-bit timer 
    T0CONbits.T0CS          = 0;   // increment on instruction cycle input
    T0CONbits.T0SE          = 0;   // increment on low--> high transition of clock
    T0CONbits.PSA           = 1;   // T0 prescaler  assigned to 1:1
    RCONbits.IPEN           = 1;   // Enable Interrupt Priorities
    INTCONbits.GIEL         = 1;   // Enable Low Priority Interrupt
    INTCONbits.GIEH         = 0;   // disable high priority interrupts
    INTCONbits.GIE          = 1;   // Enable Global Interrupts            
    INTCONbits.PEIE         = 1;   // Enable device interrupts
    INTCONbits.TMR0IE       = 1;   // Enable Timer0 Interrupt
    INTCON2bits.TMR0IP      = 0;   // TMR0 set to low Priority Interrupt
    INTCONbits.TMR0IF       = 0;   // T0 int flag bit cleared before starting
    T0CONbits.TMR0ON        = 1;   // timer0 START
}

/*****************************************************************************/
/* init */
/*****************************************************************************/
void init() {
  
    // Signal
     initSignal();

    // RS232
	if (IN0 & IN1 & IN2) initUSART(); // Serial USART init on master board only
    
    // ECAN
	gl_dataInCounter=0;
    TRISBbits.TRISB3 = 1; // CANRX input setting
    ECANInitialize(); // init ECAN

    // Main settings + Start timer
    PIC18FMainSettings(); 

}

/*****************************************************************************/
/* calibration */
/*****************************************************************************/
void calibration() {

	 unsigned short trackNumberCalibration;
	 unsigned char 	trackNumber;

	if (gl_inputCounter==0) printf(CALIBRATION);
	gl_mutex=1;	gl_calibration=TRUE; gl_mutex = 0;
	for(trackNumberCalibration=0;trackNumberCalibration<TIMECALIBRATION;trackNumberCalibration++);

    for(trackNumber=0;trackNumber<4;trackNumber++) {
	  gl_noVehicule[trackNumber]=0xFF;
	}
	for(trackNumberCalibration=0;trackNumberCalibration<TIMECALIBRATION;trackNumberCalibration++);	
	gl_mutex=1;	gl_calibration=FALSE;  gl_mutex = 0;

	// TRACE
	//for (trackNumber=0;trackNumber<4;trackNumber++) {
	//	if (gl_inputCounter==0) printf("\n\rTrack %d => %u",trackNumber,gl_noVehicule[trackNumber]);
	//}
}

//////////////////////////////////////////////////////////////////////////////
// EVENT MANAGEMENT
//////////////////////////////////////////////////////////////////////////////

/*****************************************************************************/
/* getEventRequestFromTrack() */
/*****************************************************************************/
unsigned char getEventRequestFromTrack(struct inputRequest* request) {

	 unsigned char trackNumber;

	for (trackNumber=0;trackNumber<4;trackNumber++) {
		if (gl_trackNotification[trackNumber]==TRUE) {
			initRequest(request);
			request->boardNumber=gl_boardNumber;
			request->eventRequest.trackEvent=TRUE;
			request->eventRequest.eventBoardTrackNumber=gl_boardNumber;
			request->eventRequest.eventTrackNumber=trackNumber;
			request->eventRequest.eventVehicleStatus=gl_OUTSTATchar[trackNumber]==1 ? ONTRACKValue : OFFTRACKValue;
			gl_mutex=1;gl_trackNotification[trackNumber]=FALSE;gl_mutex=0;
			return (TRUE);
		}
	}
	return(FALSE);	
}

/*****************************************************************************/
/* getEventRequestFromGPIO() */
/*****************************************************************************/
unsigned char getEventRequestFromGPIO(struct inputRequest* request) {

	 unsigned char GPIONumber;

	for (GPIONumber=0;GPIONumber<3;GPIONumber++) {
		if (gl_GPIONotification[GPIONumber]==TRUE) {
			initRequest(request);
			request->boardNumber=gl_boardNumber;
			request->eventRequest.GPIOEvent=TRUE;
			request->eventRequest.eventBoardGPIONumber=gl_boardNumber;
			request->eventRequest.eventGPIONumber=GPIONumber;
			request->eventRequest.eventGPIOLevel=gl_GPIOchar[GPIONumber];
			gl_mutex=1;gl_GPIONotification[GPIONumber]=FALSE;gl_mutex=0;
			return(TRUE);
		}
	}
	return(FALSE);	
}


/*****************************************************************************/
/* MAIN */
/*****************************************************************************/
void main()
{
     unsigned char   prompt[20];

	// Full init of PIC18F
    init();
	gl_inputCounter=0;
	sprintf(gl_inputString,"");
	gl_parserErrorCode=0;

	// Print header
	printfLine();
    printf(RAIL_DRIVER_HEADER);
	printfLine();

	// CALIBRATION
    calibration();

	// START MAIN LOOP
	sprintf(prompt,"\n\rBoard %d > ",gl_boardNumber);
	printf("%s",prompt);

    while (1){
		while(1) {

			// Get current status on tracks
			if (getEventRequestFromTrack(&gl_request)==TRUE) {
				break;
			}
			// Get current status on GPIO
			if (getEventRequestFromGPIO(&gl_request)==TRUE) {
				break;
			}
			
			// Get Request from CAN Bus
			if (getInputRequestFromCAN(&gl_request)==TRUE) {
				break;		
			}

			// Get Request from RS232 input
			if (getInputRequestFromUSART(gl_inputString,&gl_inputCounter)==TRUE) {
				if (strlen(gl_inputString)!=0) {

					// Call parser to analyse input request
					gl_parserErrorCode=0;
					gl_inputCounter=0;
	       			if (parser(gl_inputString,&gl_request)==TRUE) {
						sprintf(gl_inputString,"");
						break;
					}
					else {
						gl_inputCounter=0;
						sprintf(gl_inputString,"");
						traceError();
						gl_parserErrorCode=0;
						printf("%s",prompt);
					}		
				}
				else printf("\%s",prompt);
			}
		}

		// Manage request	
		if (manageRequest(&gl_request)==TRUE) {
			if (gl_inputCounter==0) printf("\n\rOK %d",gl_boardNumber);
		}
		else {
			traceError();
			gl_parserErrorCode=0;
		}
		if (gl_inputCounter==0) printf("%s",prompt);
	}
}